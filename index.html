<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ANATOMLE | Pro Integration v18</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@900&family=EB+Garamond:wght@400;700&display=swap');
        body { font-family: 'EB Garamond', serif; background-color: #050505; color: #d6d3d1; margin: 0; overflow: hidden; }
        
        /* Layout Grid */
        #root { position: relative; z-index: 50; width: 450px; height: 100vh; pointer-events: none; }
        .sidebar { pointer-events: auto; background: rgba(8, 8, 8, 0.96); border-right: 1px solid #222; height: 100%; display: flex; flex-direction: column; }
        #canvas-container { position: absolute; right: 0; top: 0; width: calc(100% - 450px); height: 100vh; z-index: 10; background: radial-gradient(circle at center, #111 0%, #000 100%); }
        
        /* UI Utilities */
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        .suggestion-item { cursor: pointer; border-bottom: 1px solid #222; transition: background 0.2s; }
        .suggestion-item:hover { background: #10b981; color: black; }
        
        /* Animations */
        @keyframes flash-green { 0% { background-color: rgba(16, 185, 129, 0.5); } 100% { background-color: transparent; } }
        .animate-flash { animation: flash-green 1s ease-out; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;

        // --- 1. FULL DATA GRAPH (Expanded) ---
        const SKELETON_GRAPH = {
            'Frontal Bone': ['Parietal Bone', 'Ethmoid', 'Sphenoid', 'Nasal Bone', 'Maxilla', 'Zygomatic Bone'],
            'Parietal Bone': ['Frontal Bone', 'Temporal Bone', 'Occipital Bone', 'Sphenoid'],
            'Occipital Bone': ['Parietal Bone', 'Temporal Bone', 'Atlas (C1)'],
            'Temporal Bone': ['Parietal Bone', 'Occipital Bone', 'Sphenoid', 'Zygomatic Bone', 'Mandible'],
            'Mandible': ['Temporal Bone', 'Maxilla'],
            'Maxilla': ['Frontal Bone', 'Nasal Bone', 'Zygomatic Bone', 'Mandible'],
            'Zygomatic Bone': ['Frontal Bone', 'Sphenoid', 'Temporal Bone', 'Maxilla'],
            'Atlas (C1)': ['Occipital Bone', 'Axis (C2)'],
            'Axis (C2)': ['Atlas (C1)', 'Cervical Vertebrae'],
            'Cervical Vertebrae': ['Axis (C2)', 'Thoracic Vertebrae'],
            'Thoracic Vertebrae': ['Cervical Vertebrae', 'Lumbar Vertebrae', 'Ribs', 'Sternum'],
            'Sternum': ['Thoracic Vertebrae', 'Clavicle', 'Ribs'],
            'Ribs': ['Thoracic Vertebrae', 'Sternum'],
            'Lumbar Vertebrae': ['Thoracic Vertebrae', 'Sacrum'],
            'Sacrum': ['Lumbar Vertebrae', 'Coccyx', 'Ilium'],
            'Coccyx': ['Sacrum'],
            'Ilium': ['Sacrum', 'Pubis', 'Ischium', 'Femur'],
            'Pubis': ['Ilium', 'Ischium'],
            'Ischium': ['Ilium', 'Pubis'],
            'Clavicle': ['Sternum', 'Scapula'],
            'Scapula': ['Clavicle', 'Humerus'],
            'Humerus': ['Scapula', 'Radius', 'Ulna'],
            'Radius': ['Humerus', 'Ulna', 'Carpals'],
            'Ulna': ['Humerus', 'Radius', 'Carpals'],
            'Femur': ['Ilium', 'Patella', 'Tibia'],
            'Patella': ['Femur', 'Tibia'],
            'Tibia': ['Femur', 'Patella', 'Fibula', 'Talus'],
            'Fibula': ['Tibia', 'Talus'],
            'Talus': ['Tibia', 'Fibula', 'Calcaneus'],
            'Carpals': ['Radius', 'Ulna', 'Metacarpals'],
            'Metacarpals': ['Carpals', 'Phalanges'],
            'Phalanges': ['Metacarpals']
        };

        const TWIN_BONES = [
            ['Radius', 'Ulna'], 
            ['Tibia', 'Fibula'], 
            ['Ilium', 'Ischium', 'Pubis'],
            ['Carpals', 'Metacarpals'] // Logical grouping
        ];

        // --- 2. 3D MAPPING (Wildcard + Specifics) ---
        const MAPPING_3D = {
            "Frontal Bone": "Frontal", "Parietal Bone": "Parietal", "Occipital Bone": "Occipital",
            "Temporal Bone": "Temporal", "Mandible": "Mandible", "Maxilla": "Maxilla", "Zygomatic Bone": "Zygomatic",
            "Atlas (C1)": "Atlas", "Axis (C2)": "Axis", 
            "Cervical Vertebrae": "Cervical", "Thoracic Vertebrae": "Thoracic", "Lumbar Vertebrae": "Lumbar",
            "Sacrum": "Sacrum", "Coccyx": "Coccyx", "Sternum": "Sternum", "Ribs": "Rib",
            "Clavicle": "Clavicle", "Scapula": "Scapula", "Humerus": "Humerus", "Radius": "Radius", "Ulna": "Ulna",
            "Carpals": "Carpal", "Metacarpals": "Metacarpal", "Phalanges": "Phalan",
            "Ilium": "Ilium", "Ischium": "Ischium", "Pubis": "Pubis",
            "Femur": "Femur", "Patella": "Patella", "Tibia": "Tibia", "Fibula": "Fibula", "Talus": "Talus"
        };

        const findShortestPath = (start, end) => {
            const queue = [[start]]; const visited = new Set([start]);
            while (queue.length > 0) {
                const path = queue.shift(); const current = path[path.length - 1];
                if (current === end) return path;
                for (const neighbor of (SKELETON_GRAPH[current] || [])) {
                    if (!visited.has(neighbor)) { visited.add(neighbor); queue.push([...path, neighbor]); }
                }
            }
            return null;
        };

        function App() {
            const [target, setTarget] = useState({ start: '', end: '', path: [] });
            const [chain, setChain] = useState([]);
            const [guessesLeft, setGuessesLeft] = useState(10);
            const [badGuesses, setBadGuesses] = useState([]);
            const [inputValue, setInputValue] = useState('');
            const [lastFilled, setLastFilled] = useState(null);

            // --- v18 LOGIC: RANDOMIZATION ---
            const initGame = useCallback(() => {
                const bones = Object.keys(SKELETON_GRAPH);
                let s, e, p;
                do {
                    s = bones[Math.floor(Math.random() * bones.length)];
                    e = bones[Math.floor(Math.random() * bones.length)];
                    p = findShortestPath(s, e);
                } while (!p || p.length < 3 || p.length > 7);
                
                setTarget({ start: s, end: e, path: p });
                // v18 Rule: Start is revealed, End is a visible target, rest is hidden initially
                setChain([{ bone: s, emoji: 'ðŸ“', hidden: false, id: 0 }]);
                setGuessesLeft(10);
                setBadGuesses([]);
                setInputValue('');
            }, []);

            useEffect(() => { initGame(); }, [initGame]);

            // --- 3D SYNC ---
            useEffect(() => {
                const revealed = chain.filter(c => !c.hidden).map(c => c.bone);
                if (window.update3D) window.update3D(revealed);
            }, [chain]);

            // --- v18 LOGIC: GUESS HANDLING & PATH JUMPING ---
            const submitGuess = (guess) => {
                setGuessesLeft(prev => prev - 1); // Always cost a guess
                
                // 1. Is it a valid neighbor or jump?
                const lastVisible = [...chain].reverse().find(n => !n.hidden);
                const pathToEnd = findShortestPath(lastVisible.bone, guess);
                
                if (pathToEnd) {
                    // Logic: Reveal the path to the guess
                    // If the path length > 2, it means we skipped bones -> create '???' slots
                    const newItems = [];
                    // Start from 1 to avoid duplicating lastVisible
                    for (let k = 1; k < pathToEnd.length; k++) {
                        const boneName = pathToEnd[k];
                        const isGuess = boneName === guess;
                        const isHidden = !isGuess; 
                        
                        // Check if we already have this bone in the chain to avoid dupes (simple check)
                        const exists = chain.some(c => c.bone === boneName);
                        if (!exists) {
                            newItems.push({
                                bone: boneName,
                                hidden: isHidden,
                                emoji: isGuess ? 'ðŸ§¬' : '', // DNA for jump, check for neighbor
                                id: Date.now() + k
                            });
                        } else if (isGuess) {
                             // If it existed but was hidden, reveal it
                             setChain(prev => prev.map(c => c.bone === guess ? { ...c, hidden: false, emoji: 'âœ…' } : c));
                             return;
                        }
                    }
                    
                    if (newItems.length > 0) {
                        setChain(prev => [...prev, ...newItems]);
                        setLastFilled(guess);
                    }
                } else {
                    // Bad guess
                    setBadGuesses(prev => [guess, ...prev]);
                }
                setInputValue('');
            };

            const suggestions = useMemo(() => {
                if (!inputValue) return [];
                return Object.keys(SKELETON_GRAPH).filter(b => b.toLowerCase().includes(inputValue.toLowerCase())).slice(0, 5);
            }, [inputValue]);

            // --- GROUPING LOGIC (Twin Bones) ---
            const groupedDisplay = useMemo(() => {
                return chain.reduce((acc, item) => {
                    const lastGroup = acc.length > 0 ? acc[acc.length - 1] : null;
                    const lastBone = lastGroup ? lastGroup[0].bone : null;
                    
                    // Check if current item is a twin of the last item's group
                    const isTwin = TWIN_BONES.some(pair => 
                        pair.includes(item.bone) && lastBone && pair.includes(lastBone)
                    );

                    if (isTwin) {
                        lastGroup.push(item);
                    } else {
                        acc.push([item]);
                    }
                    return acc;
                }, []);
            }, [chain]);

            return (
                <div className="sidebar p-8 shadow-2xl">
                    <header className="mb-8">
                        <h1 className="text-5xl font-black text-white tracking-tighter mb-2">ANATOMLE</h1>
                        <div className="flex items-center gap-3 border-b border-stone-800 pb-4">
                            <span className="bg-emerald-500 text-black text-[10px] font-black px-2 py-1 uppercase rounded">PRO v18</span>
                            <span className="text-[10px] text-stone-500 tracking-widest uppercase">Clinical Integration</span>
                        </div>
                    </header>

                    {/* TARGET CARD */}
                    <div className="bg-stone-900/60 p-6 rounded-lg border border-stone-800 mb-6 flex justify-between items-end">
                        <div>
                            <p className="text-[10px] text-stone-500 uppercase font-bold mb-1">Diagnostic Target</p>
                            <div className="flex items-center gap-2 text-white">
                                <span className="font-bold uppercase text-emerald-400">{target.start}</span>
                                <span className="text-stone-600">â†’</span>
                                <span className="font-bold uppercase text-white">{target.end}</span>
                            </div>
                        </div>
                        <div className="text-right">
                            <p className="text-[10px] text-stone-500 uppercase font-bold">Guesses</p>
                            <p className={`text-3xl font-black ${guessesLeft < 4 ? 'text-red-500' : 'text-white'}`}>{guessesLeft}</p>
                        </div>
                    </div>

                    {/* CHAIN DISPLAY */}
                    <div className="flex-1 overflow-y-auto space-y-4 mb-6 pr-2 custom-scrollbar">
                        {groupedDisplay.map((group, gIdx) => (
                            <div key={gIdx} className="relative">
                                {/* Connector Line */}
                                {gIdx < groupedDisplay.length - 1 && (
                                    <div className="absolute left-6 top-full h-4 w-[1px] bg-stone-800 z-0"></div>
                                )}
                                
                                <div className="flex gap-2 relative z-10">
                                    {group.map((node) => (
                                        <div key={node.id} 
                                             className={`flex-1 p-4 rounded border transition-all duration-300 ${node.hidden ? 'border-dashed border-stone-800 bg-transparent opacity-40' : 'bg-stone-900 border-stone-700 shadow-lg'} ${lastFilled === node.bone ? 'animate-flash' : ''}`}>
                                            <div className="flex justify-between items-center">
                                                <span className="text-[10px] font-black uppercase tracking-widest text-stone-300">
                                                    {node.hidden ? '???' : node.bone}
                                                </span>
                                                <span className="text-xs">{node.emoji}</span>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>

                    {/* CONTROLS */}
                    <div className="mt-auto pt-6 border-t border-stone-800 space-y-4">
                        <div className="relative group">
                            <input 
                                className="w-full bg-black border border-stone-800 p-4 text-white outline-none focus:border-emerald-500 italic text-sm transition-all"
                                placeholder="Identify structure..."
                                value={inputValue}
                                onChange={e => setInputValue(e.target.value)}
                            />
                            {suggestions.length > 0 && (
                                <div className="absolute bottom-full left-0 w-full bg-stone-900 border border-stone-700 mb-2 rounded-t-lg overflow-hidden shadow-2xl z-[100]">
                                    {suggestions.map(s => (
                                        <div key={s} onClick={() => submitGuess(s)} className="suggestion-item p-3 text-[10px] uppercase font-black text-stone-400">
                                            {s}
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>

                        {badGuesses.length > 0 && (
                            <div className="p-3 border border-red-900/30 bg-red-950/10 rounded flex flex-wrap gap-2">
                                {badGuesses.map((g, i) => (
                                    <span key={i} className="text-[9px] font-bold text-red-500 bg-red-900/20 px-2 py-1 rounded border border-red-900/30 uppercase">{g}</span>
                                ))}
                            </div>
                        )}

                        <button onClick={initGame} className="w-full py-4 bg-white text-black text-[10px] font-black uppercase tracking-[0.2em] hover:bg-emerald-500 hover:text-white transition-all">
                            Next Patient
                        </button>
                    </div>
                </div>
            );
        }

        // --- 3. 3D ENGINE (Wildcard Matcher) ---
        const init3D = () => {
            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            camera.position.set(2, 2, 5); // Angle view
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const spot = new THREE.SpotLight(0xffffff, 1.5);
            spot.position.set(10, 20, 10);
            scene.add(spot);

            // Loader
            const draco = new THREE.DRACOLoader();
            draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
            const loader = new THREE.GLTFLoader();
            loader.setDRACOLoader(draco);

            let skeleton;
            loader.load('./overview-skeleton.glb', (gltf) => {
                skeleton = gltf.scene;
                scene.add(skeleton);
                
                // Initial Dark Material
                skeleton.traverse(node => {
                    if (node.isMesh) {
                        node.material = new THREE.MeshStandardMaterial({
                            color: 0x111111,
                            roughness: 0.6,
                            metalness: 0.1,
                            transparent: true,
                            opacity: 0.2,
                            wireframe: true // Ghost mode
                        });
                    }
                });
            });

            // The Listener
            window.update3D = (revealedBones) => {
                if (!skeleton) return;
                
                skeleton.traverse(node => {
                    if (node.isMesh) {
                        // Check match against MAPPING_3D keywords
                        const shouldHighlight = revealedBones.some(boneName => {
                            const keyword = MAPPING_3D[boneName];
                            return keyword && node.name.includes(keyword);
                        });

                        if (shouldHighlight) {
                            // Emerald Glow
                            node.material = new THREE.MeshStandardMaterial({
                                color: 0x10b981,
                                emissive: 0x064e3b,
                                emissiveIntensity: 0.5,
                                roughness: 0.2,
                                metalness: 0.8,
                                transparent: false,
                                opacity: 1.0
                            });
                        }
                    }
                });
            };

            const animate = () => {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            };
            animate();
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        init3D();
    </script>
</body>
</html>
