<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ANATOMLE | Pro v18.7</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@900&family=EB+Garamond:wght@400;700&display=swap');
        body { 
            font-family: 'EB Garamond', serif; 
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: #d6d3d1; 
            margin: 0; 
            overflow: hidden; 
        }
        #canvas-container { 
            position: absolute; 
            right: 0; 
            top: 0; 
            width: calc(100% - 400px); 
            height: 100vh; 
            z-index: 10; 
            background: linear-gradient(135deg, #334155 0%, #1e293b 100%);
        }
        .sidebar { 
            width: 400px; 
            height: 100vh; 
            background: rgba(15, 23, 42, 0.98); 
            border-right: 1px solid #334155; 
            position: relative; 
            z-index: 50; 
            display: flex; 
            flex-direction: column; 
            pointer-events: auto; 
            box-shadow: 2px 0 20px rgba(0,0,0,0.5);
        }
        .custom-scrollbar::-webkit-scrollbar { width: 2px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; }
        .suggestion-item:hover { background: #3b82f6; color: white; padding-left: 1rem; cursor: pointer; }
        .victory-bg { background: radial-gradient(circle, rgba(16,185,129,0.3) 0%, rgba(0,0,0,1) 100%); }
        .loss-bg { background: radial-gradient(circle, rgba(239,68,68,0.3) 0%, rgba(0,0,0,1) 100%); }
        .failure-item {
            animation: shake 0.3s ease-in-out;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;

        const SKELETON_GRAPH = {
            'Frontal Bone': ['Parietal Bone', 'Ethmoid', 'Sphenoid', 'Nasal Bone', 'Maxilla', 'Zygomatic Bone'],
            'Parietal Bone': ['Frontal Bone', 'Temporal Bone', 'Occipital Bone', 'Sphenoid'],
            'Occipital Bone': ['Parietal Bone', 'Temporal Bone', 'Atlas (C1)'],
            'Atlas (C1)': ['Occipital Bone', 'Axis (C2)'],
            'Axis (C2)': ['Atlas (C1)', 'Cervical Vertebrae'],
            'Cervical Vertebrae': ['Axis (C2)', 'Thoracic Vertebrae'],
            'Thoracic Vertebrae': ['Cervical Vertebrae', 'Lumbar Vertebrae', 'Ribs'], // Removed direct Sternum - ribs are the bridge
            'Sternum': ['Clavicle', 'Ribs'], // Removed direct Thoracic - connected via ribs
            'Ribs': ['Thoracic Vertebrae', 'Sternum'], // Ribs bridge spine to sternum
            'Clavicle': ['Sternum', 'Scapula'],
            'Scapula': ['Clavicle', 'Humerus'],
            'Humerus': ['Scapula', 'Radius', 'Ulna'],
            'Radius': ['Humerus', 'Ulna', 'Carpals'],
            'Ulna': ['Humerus', 'Radius', 'Carpals'],
            'Carpals': ['Radius', 'Ulna', 'Metacarpals'],
            'Metacarpals': ['Carpals', 'Phalanges (Hand)'],
            'Phalanges (Hand)': ['Metacarpals'],
            'Lumbar Vertebrae': ['Thoracic Vertebrae', 'Sacrum'],
            'Sacrum': ['Lumbar Vertebrae', 'Ilium'],
            'Ilium': ['Sacrum', 'Pubis', 'Ischium', 'Femur'],
            'Femur': ['Ilium', 'Tibia', 'Patella'],
            'Patella': ['Femur', 'Tibia'],
            'Tibia': ['Femur', 'Patella', 'Fibula', 'Talus'],
            'Fibula': ['Tibia', 'Talus'],
            'Talus': ['Tibia', 'Fibula', 'Calcaneus', 'Navicular'],
            'Calcaneus': ['Talus', 'Cuboid'],
            'Navicular': ['Talus', 'Cuneiforms'],
            'Cuboid': ['Calcaneus', 'Metatarsals'],
            'Cuneiforms': ['Navicular', 'Metatarsals'],
            'Metatarsals': ['Cuboid', 'Cuneiforms', 'Phalanges (Foot)'],
            'Phalanges (Foot)': ['Metatarsals']
        };

        // Define anatomically paired bones that should display side by side
        const TWIN_BONES = {
            'Radius': 'Ulna',
            'Ulna': 'Radius',
            'Tibia': 'Fibula',
            'Fibula': 'Tibia',
            'Talus': 'Calcaneus',
            'Calcaneus': 'Talus'
        };

        // Helper to check if two bones are twins
        const areTwins = (bone1, bone2) => {
            return TWIN_BONES[bone1] === bone2 || TWIN_BONES[bone2] === bone1;
        };

        const MAPPING_3D = {
            "Frontal Bone": "Frontal", "Parietal Bone": "Parietal", "Occipital Bone": "Occipital",
            "Atlas (C1)": "Atlas", "Axis (C2)": "Axis", "Cervical Vertebrae": "Cervical",
            "Thoracic Vertebrae": "Thoracic", "Lumbar Vertebrae": "Lumbar", "Sacrum": "Sacrum",
            "Sternum": "sternum", "Clavicle": "Clavicl", "Scapula": "Scapula",
            "Humerus": "Humerus", "Radius": "Radius", "Ulna": "Ulna",
            "Ilium": "Ilium", "Femur": "Femur", "Tibia": "Tibia", "Fibula": "Fibula", 
            "Ribs": "Rib_", "Patella": "Patellar",
            // Hand bones - matching actual GLB patterns
            "Carpals": "Capitate", // Representative carpal bone (could also match Hamate, Lunate, Trapezium, etc.)
            "Metacarpals": "metacarpal_boner", // Matches all 5 metacarpal bones
            "Phalanges (Hand)": "d_finger", // Matches hand phalanges with digit format (2d_finger, 3d_finger)
            // Foot bones - matching actual GLB patterns
            "Talus": "Talus",
            "Calcaneus": "Calcaneus",
            "Navicular": "Navicular_boner",
            "Cuboid": "Cuboid_boner",
            "Cuneiforms": "cuneiform_boner", // Matches Lateral, Medial, Intermediate cuneiform
            "Metatarsals": "metatarsal_boner", // Matches all 5 metatarsal bones
            "Phalanges (Foot)": "_of_foot" // Matches all toe phalanges (have _of_footr suffix)
        };

        const findShortestPath = (start, end) => {
            const queue = [[start]]; const visited = new Set([start]);
            while (queue.length > 0) {
                const path = queue.shift(); const current = path[path.length - 1];
                if (current === end) return path;
                for (const neighbor of (SKELETON_GRAPH[current] || [])) {
                    if (!visited.has(neighbor)) { visited.add(neighbor); queue.push([...path, neighbor]); }
                }
            }
            return null;
        };

        // Check if a bone is on ANY valid path from start to target
        const isOnValidPath = (bone, start, target) => {
            // Can we reach the bone from start?
            const pathToGuess = findShortestPath(start, bone);
            if (!pathToGuess) return false;
            
            // Can we reach target from the bone?
            const pathFromGuess = findShortestPath(bone, target);
            if (!pathFromGuess) return false;
            
            return true; // Valid path exists through this bone
        };

        function App() {
            const [target, setTarget] = useState({ start: '', end: '', path: [] });
            const [chain, setChain] = useState([]);
            const [guessesLeft, setGuessesLeft] = useState(10);
            const [maxGuesses, setMaxGuesses] = useState(10);
            const [badGuesses, setBadGuesses] = useState([]); // Off any valid path
            const [detours, setDetours] = useState([]); // Valid but not on optimal path
            const [inputValue, setInputValue] = useState('');
            const [gameState, setGameState] = useState('playing');
            const [showReveal, setShowReveal] = useState(false);

            const initGame = useCallback(() => {
                const bones = Object.keys(SKELETON_GRAPH);
                let s, e, p;
                do {
                    s = bones[Math.floor(Math.random() * bones.length)];
                    e = bones[Math.floor(Math.random() * bones.length)];
                    p = findShortestPath(s, e);
                } while (!p || p.length < 4 || p.length > 8 || s === e);

                setTarget({ start: s, end: e, path: p });
                // Initialize chain with all bones in correct order, mark first as guessed
                const initialChain = p.map((bone, idx) => ({
                    bone,
                    type: idx === 0 ? 'start' : 'path',
                    guessed: idx === 0 // Only start is guessed initially
                }));
                setChain(initialChain);
                // Guesses = path length (excluding start which is free) + 3 extra attempts
                const optimalGuesses = p.length - 1; // -1 because start is free
                const totalGuesses = optimalGuesses + 3;
                setGuessesLeft(totalGuesses);
                setMaxGuesses(totalGuesses); 
                setBadGuesses([]);
                setDetours([]); // Reset detours
                setInputValue(''); 
                setGameState('playing');
                setShowReveal(false);
                if (window.reset3D) window.reset3D();
            }, []);

            useEffect(() => { initGame(); }, [initGame]);

            useEffect(() => {
                const highlights = [];
                
                // If revealing, show the full correct path with missing links highlighted
                if (showReveal && gameState === 'lost') {
                    chain.forEach((item, idx) => {
                        const isLastBone = idx === chain.length - 1;
                        if (item.guessed && !isLastBone) {
                            highlights.push({ name: item.bone, type: item.type });
                        } else if (!item.guessed && !isLastBone) {
                            highlights.push({ name: item.bone, type: 'reveal' });
                        } else if (isLastBone) {
                            highlights.push({ name: item.bone, type: 'end' });
                        }
                    });
                } else {
                    // Normal game state: show guessed bones
                    chain.forEach((item, idx) => {
                        const isLastBone = idx === chain.length - 1;
                        if (item.guessed && !isLastBone) {
                            highlights.push({ name: item.bone, type: item.type });
                        } else if (isLastBone) {
                            highlights.push({ name: item.bone, type: 'end' });
                        }
                    });
                    
                    // Show detours (valid but suboptimal)
                    detours.forEach(g => highlights.push({ name: g, type: 'detour' }));
                    
                    // Show bad guesses
                    badGuesses.forEach(g => highlights.push({ name: g, type: 'bad' }));
                }
                
                if (window.update3D) window.update3D(highlights);
            }, [chain, badGuesses, detours, showReveal, gameState]);

            const submitGuess = (guess) => {
                if (gameState !== 'playing' || guess === target.end) return;
                
                // Check if guess is on the optimal (shortest) path
                const isOnOptimalPath = target.path.includes(guess);
                
                if (isOnOptimalPath) {
                    // OPTIMAL PATH: On the shortest route ‚úì
                    setGuessesLeft(prev => prev - 1);
                    setChain(prev => prev.map(item => 
                        item.bone === guess ? { ...item, guessed: true } : item
                    ));
                    
                    // Check win condition: all bones guessed except the last one (target.end)
                    const updatedChain = chain.map(item => 
                        item.bone === guess ? { ...item, guessed: true } : item
                    );
                    const allPathBonesGuessed = updatedChain
                        .slice(0, -1) // Exclude target.end
                        .every(item => item.guessed);
                    
                    if (allPathBonesGuessed) {
                        setGameState('won');
                        return;
                    }
                } else {
                    // Not on optimal path - check if it's on ANY valid path
                    const isValidDetour = isOnValidPath(guess, target.start, target.end);
                    
                    if (isValidDetour) {
                        // SUBOPTIMAL PATH: Valid but longer route ‚ö†
                        setDetours(prev => [...new Set([guess, ...prev])]);
                        setGuessesLeft(prev => prev - 1);
                    } else {
                        // FAILURE: Not on any valid path ‚úó
                        setBadGuesses(prev => [...new Set([guess, ...prev])]);
                        setGuessesLeft(prev => prev - 1);
                    }
                }
                
                if (guessesLeft <= 1) setGameState('lost');
                setInputValue('');
            };

            const suggestions = useMemo(() => {
                if (!inputValue) return [];
                const guessedBones = chain.filter(c => c.guessed).map(c => c.bone);
                return Object.keys(SKELETON_GRAPH)
                    .filter(b => 
                        b.toLowerCase().includes(inputValue.toLowerCase()) && 
                        !guessedBones.includes(b) && 
                        b !== target.end &&
                        !badGuesses.includes(b) &&
                        !detours.includes(b) // Also exclude detours
                    ).slice(0, 5);
            }, [inputValue, chain, target, badGuesses, detours]);

            return (
                <div className="sidebar p-6">
                    <header className="mb-4">
                        <h1 className="text-3xl font-black text-white tracking-tighter uppercase">Anatomle</h1>
                        <div className="flex justify-between items-center border-b border-slate-700 pb-2">
                            <span className="text-[9px] text-slate-500 tracking-[0.3em] uppercase">Clinical Pro v18.7</span>
                            <span className={`text-xs font-bold ${guessesLeft < 4 ? 'text-red-400' : 'text-emerald-400'}`}>{guessesLeft} Guesses</span>
                        </div>
                    </header>

                    <div className="bg-slate-800/40 p-3 border border-slate-700 mb-4 rounded flex justify-between">
                        <div>
                            <p className="text-[8px] text-slate-500 uppercase font-bold">Start</p>
                            <p className="text-[10px] font-bold uppercase text-emerald-400">{target.start}</p>
                        </div>
                        <div className="text-right">
                            <p className="text-[8px] text-slate-500 uppercase font-bold">Target</p>
                            <p className="text-[10px] font-bold uppercase text-amber-400">{target.end}</p>
                        </div>
                    </div>

                    {/* Detours Section - Valid but not optimal */}
                    {detours.length > 0 && (
                        <div className="mb-4">
                            <p className="text-[8px] text-amber-400 uppercase font-bold mb-2 tracking-wider">‚ö†Ô∏è Longer Routes</p>
                            <div className="flex flex-wrap gap-1.5">
                                {detours.map((g, i) => (
                                    <div key={i} className="text-[9px] font-bold text-amber-400 bg-amber-900/30 px-2.5 py-1 border border-amber-800/40 uppercase tracking-tight rounded">
                                        {g}
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Failed Guesses Section - Horizontal */}
                    {badGuesses.length > 0 && (
                        <div className="mb-4">
                            <p className="text-[8px] text-red-400 uppercase font-bold mb-2 tracking-wider">‚ùå Failed Attempts</p>
                            <div className="flex flex-wrap gap-1.5">
                                {badGuesses.map((g, i) => (
                                    <div key={i} className="failure-item text-[9px] font-bold text-red-400 bg-red-900/30 px-2.5 py-1 border border-red-800/40 uppercase tracking-tight rounded">
                                        {g}
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Correct Path Chain */}
                    <div className="flex-1 overflow-y-auto custom-scrollbar space-y-1 mb-4">
                        <p className="text-[8px] text-slate-500 uppercase font-bold mb-2 tracking-wider">üß¨ Your Path</p>
                        {chain.map((item, idx) => {
                            const isLastBone = idx === chain.length - 1; // This is the target
                            const isMissing = showReveal && gameState === 'lost' && !item.guessed && !isLastBone;
                            
                            // Check if this bone is a twin with the next bone
                            const nextItem = chain[idx + 1];
                            const isTwinWithNext = nextItem && areTwins(item.bone, nextItem.bone);
                            
                            // Skip rendering if this is the second twin (it will be rendered with the first)
                            const prevItem = chain[idx - 1];
                            const isTwinWithPrev = prevItem && areTwins(item.bone, prevItem.bone);
                            if (isTwinWithPrev) return null;
                            
                            // Single bone render
                            const renderBone = (boneItem, boneIdx, isInPair = false) => {
                                const boneIsLastBone = boneIdx === chain.length - 1;
                                const boneIsMissing = showReveal && gameState === 'lost' && !boneItem.guessed && !boneIsLastBone;
                                
                                return (
                                    <div className={`p-2 border transition-all ${isInPair ? 'flex-1' : ''} ${
                                        !boneItem.guessed && !boneIsLastBone && !showReveal
                                            ? 'border-dashed border-slate-700/40 opacity-20' 
                                            : boneIsMissing 
                                                ? 'bg-fuchsia-900/20 border-fuchsia-700/40 shadow-sm' 
                                                : boneIsLastBone
                                                    ? 'bg-amber-900/20 border-amber-700/40 shadow-sm'
                                                    : 'bg-slate-800 border-slate-600 shadow-sm'
                                    }`}>
                                        <div className="flex justify-between items-center text-[9px] font-black uppercase tracking-widest">
                                            <span className={
                                                boneItem.type === 'start' ? 'text-emerald-400' : 
                                                boneIsLastBone ? 'text-amber-400' :
                                                boneIsMissing ? 'text-fuchsia-400' : 
                                                'text-blue-400'
                                            }>
                                                {showReveal && gameState === 'lost' ? boneItem.bone : 
                                                 !boneItem.guessed && !boneIsLastBone ? '???' : boneItem.bone}
                                            </span>
                                            <span>
                                                {boneItem.type === 'start' ? 'üìç' : 
                                                 boneIsLastBone ? 'üéØ' :
                                                 boneIsMissing ? 'üîó' : 'üß¨'}
                                            </span>
                                        </div>
                                        {boneIsMissing && (
                                            <p className="text-[7px] text-fuchsia-400 mt-1 tracking-wider">MISSING LINK</p>
                                        )}
                                    </div>
                                );
                            };
                            
                            // Render twin bones side by side
                            if (isTwinWithNext) {
                                return (
                                    <div key={idx} className="flex gap-1">
                                        {renderBone(item, idx, true)}
                                        {renderBone(nextItem, idx + 1, true)}
                                    </div>
                                );
                            }
                            
                            // Render single bone
                            return (
                                <div key={idx}>
                                    {renderBone(item, idx)}
                                </div>
                            );
                        })}
                    </div>

                    <div className="mt-auto space-y-3">
                        <div className="relative">
                            <input 
                                className="w-full bg-slate-900 border border-slate-700 p-3 text-white outline-none focus:border-blue-500 text-xs italic" 
                                placeholder="Identify next structure..." 
                                value={inputValue} 
                                onChange={e => setInputValue(e.target.value)}
                                disabled={gameState !== 'playing'}
                            />
                            {suggestions.length > 0 && (
                                <div className="absolute bottom-full left-0 w-full bg-slate-900 border border-slate-700 z-[60] shadow-2xl">
                                    {suggestions.map(s => (
                                        <div 
                                            key={s} 
                                            onClick={() => submitGuess(s)} 
                                            className="suggestion-item p-3 text-[10px] uppercase font-black transition-all"
                                        >
                                            {s}
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>

                        <button 
                            onClick={initGame} 
                            className="w-full py-3 bg-white text-black text-[10px] font-black uppercase tracking-widest hover:bg-emerald-400 hover:text-white transition-all"
                        >
                            Next Case
                        </button>
                    </div>

                    {gameState !== 'playing' && !showReveal && (
                        <div className={`fixed inset-0 z-[100] flex flex-col items-center justify-center backdrop-blur-xl ${gameState === 'won' ? 'victory-bg' : 'loss-bg'}`}>
                            <div className="text-center p-12 bg-slate-950/90 border border-white/10 rounded-3xl max-w-md">
                                <h2 className="text-5xl font-black text-white mb-2 tracking-tighter uppercase">
                                    {gameState === 'won' ? '‚úì Synchronized' : '‚úó Flatline'}
                                </h2>
                                <p className="text-slate-400 text-sm mb-6">
                                    {gameState === 'won' 
                                        ? `Correct path completed with ${maxGuesses - guessesLeft}/${maxGuesses} guesses!` 
                                        : `Path not found. ${badGuesses.length} failed attempt${badGuesses.length !== 1 ? 's' : ''}.`
                                    }
                                </p>
                                
                                {gameState === 'lost' && (
                                    <div className="mb-6">
                                        <button 
                                            onClick={() => setShowReveal(!showReveal)}
                                            className="px-6 py-3 bg-fuchsia-500 text-white font-black text-xs uppercase hover:bg-fuchsia-400 transition-all"
                                        >
                                            {showReveal ? '‚úó Hide' : 'üëÅÔ∏è Reveal'} Correct Path
                                        </button>
                                        <p className="text-[10px] text-slate-500 mt-2">
                                            {showReveal ? 'Missing links shown in magenta' : 'See what you missed'}
                                        </p>
                                    </div>
                                )}
                                
                                <button 
                                    onClick={initGame} 
                                    className="px-12 py-4 bg-white text-black font-black text-xs uppercase hover:scale-105 transition-transform"
                                >
                                    Restart Diagnostic
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const init3D = () => {
            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Store controls so we can update them
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false; // Don't pan up/down
            controls.minDistance = 1; // Min zoom
            controls.maxDistance = 10; // Max zoom
            controls.maxPolarAngle = Math.PI; // Can rotate fully
            
            camera.position.set(0, 1.2, 5);
            
            // Better lighting for visibility
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);

            const draco = new THREE.DRACOLoader();
            draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
            const loader = new THREE.GLTFLoader();
            loader.setDRACOLoader(draco);

            let skeleton;
            loader.load('./overview-skeleton.glb', (gltf) => {
                skeleton = gltf.scene;
                scene.add(skeleton);
                
                // Calculate bounding box to center the model
                const box = new THREE.Box3().setFromObject(skeleton);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                // Set controls target to center of model
                controls.target.copy(center);
                controls.update();
                
                // Adjust camera to see whole model
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                cameraZ *= 1.5; // Add some padding
                
                camera.position.set(center.x, center.y, center.z + cameraZ);
                camera.lookAt(center);
                controls.update();
                
                window.reset3D();
            });

            window.reset3D = () => {
                if (!skeleton) return;
                skeleton.traverse(node => {
                    if (node.isMesh) {
                        node.material = new THREE.MeshStandardMaterial({ 
                            color: 0x475569, 
                            transparent: true, 
                            opacity: 0.25, 
                            wireframe: false 
                        });
                    }
                });
            };

            window.update3D = (bones) => {
                if (!skeleton) return;
                skeleton.traverse(node => {
                    if (node.isMesh) {
                        const match = bones.find(b => {
                            const key = MAPPING_3D[b.name];
                            if (!key) return false;
                            
                            // Special case: differentiate hand vs foot phalanges
                            if (b.name === "Phalanges (Hand)") {
                                return node.name.includes("phalanx") && !node.name.includes("footr");
                            }
                            if (b.name === "Phalanges (Foot)") {
                                return node.name.includes("phalanx") && node.name.includes("footr");
                            }
                            
                            // Special case: match all carpal bones
                            if (b.name === "Carpals") {
                                const carpalBones = ["Hamate", "Lunate", "Capitate", "Trapezium", "Trapezoid", "Scaphoid", "Pisiform", "Triquetrum"];
                                return carpalBones.some(carpal => node.name.includes(carpal));
                            }
                            
                            // Default: standard includes check
                            return node.name.includes(key);
                        });
                        
                        if (match) {
                            let col = 0x3b82f6; // Blue for correct guesses
                            let emissiveInt = 0.5;
                            
                            if (match.type === 'start') col = 0x10b981; // Green for start
                            if (match.type === 'end') col = 0xf59e0b; // Amber for end
                            if (match.type === 'detour') {
                                col = 0xf97316; // Orange for suboptimal/longer routes
                                emissiveInt = 0.6;
                            }
                            if (match.type === 'bad') { 
                                col = 0xef4444; // Red for failures
                                emissiveInt = 0.8;
                            }
                            if (match.type === 'reveal') {
                                col = 0xd946ef; // Fuchsia/Magenta for revealed missing bones
                                emissiveInt = 0.8;
                            }
                            
                            node.material = new THREE.MeshStandardMaterial({ 
                                color: col, 
                                emissive: col, 
                                emissiveIntensity: emissiveInt, 
                                transparent: false, 
                                opacity: 1 
                            });
                        } else {
                            // Reset to default gray
                            node.material = new THREE.MeshStandardMaterial({ 
                                color: 0x475569, 
                                transparent: true, 
                                opacity: 0.25, 
                                wireframe: false 
                            });
                        }
                    }
                });
            };
            
            const animate = () => { 
                requestAnimationFrame(animate);
                controls.update(); // Required for damping
                renderer.render(scene, camera); 
            };
            animate();
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        init3D();
    </script>
</body>
</html>
