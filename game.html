<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ANATOMLE | Pro v18.7</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@900&family=EB+Garamond:wght@400;700&display=swap');
        body { 
            font-family: 'EB Garamond', serif; 
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: #d6d3d1; 
            margin: 0; 
            overflow: hidden; 
        }
        #canvas-container { 
            position: absolute; 
            right: 0; 
            top: 0; 
            width: calc(100% - 400px); 
            height: 100vh; 
            z-index: 10; 
            background: linear-gradient(135deg, #334155 0%, #1e293b 100%);
        }
        .sidebar { 
            width: 400px; 
            height: 100vh; 
            background: rgba(15, 23, 42, 0.98); 
            border-right: 1px solid #334155; 
            position: relative; 
            z-index: 50; 
            display: flex; 
            flex-direction: column; 
            pointer-events: auto; 
            box-shadow: 2px 0 20px rgba(0,0,0,0.5);
        }
        .custom-scrollbar::-webkit-scrollbar { width: 2px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; }
        .suggestion-item:hover { background: #3b82f6; color: white; padding-left: 1rem; cursor: pointer; }
        .victory-bg { background: radial-gradient(circle, rgba(16,185,129,0.3) 0%, rgba(0,0,0,1) 100%); }
        .loss-bg { background: radial-gradient(circle, rgba(239,68,68,0.3) 0%, rgba(0,0,0,1) 100%); }
        .failure-item {
            animation: shake 0.3s ease-in-out;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;

        const SKELETON_GRAPH = {
            // ===== SKULL BONES =====
            'Frontal Bone': ['Parietal Bone', 'Ethmoid Bone', 'Sphenoid Bone', 'Nasal Bone', 'Maxilla', 'Zygomatic Bone'],
            'Parietal Bone': ['Frontal Bone', 'Temporal Bone', 'Occipital Bone', 'Sphenoid Bone'],
            'Occipital Bone': ['Parietal Bone', 'Temporal Bone', 'Atlas (C1)'],
            'Temporal Bone': ['Parietal Bone', 'Occipital Bone', 'Sphenoid Bone', 'Zygomatic Bone', 'Mandible'],
            'Sphenoid Bone': ['Frontal Bone', 'Parietal Bone', 'Temporal Bone', 'Ethmoid Bone', 'Zygomatic Bone', 'Palatine Bone'],
            'Ethmoid Bone': ['Frontal Bone', 'Sphenoid Bone', 'Nasal Bone', 'Lacrimal Bone'],
            'Nasal Bone': ['Frontal Bone', 'Ethmoid Bone', 'Maxilla'],
            'Lacrimal Bone': ['Ethmoid Bone', 'Maxilla'],
            'Zygomatic Bone': ['Frontal Bone', 'Temporal Bone', 'Sphenoid Bone', 'Maxilla'],
            'Maxilla': ['Frontal Bone', 'Nasal Bone', 'Zygomatic Bone', 'Lacrimal Bone', 'Palatine Bone', 'Mandible'],
            'Palatine Bone': ['Sphenoid Bone', 'Maxilla'],
            'Vomer': ['Sphenoid Bone', 'Ethmoid Bone', 'Maxilla'],
            'Inferior Nasal Concha': ['Ethmoid Bone', 'Maxilla'],
            'Mandible': ['Temporal Bone', 'Maxilla'],
            
            // ===== SPINE =====
            'Atlas (C1)': ['Occipital Bone', 'Axis (C2)'],
            'Axis (C2)': ['Atlas (C1)', 'C3 Vertebra'],
            'C3 Vertebra': ['Axis (C2)', 'C4 Vertebra'],
            'C4 Vertebra': ['C3 Vertebra', 'C5 Vertebra'],
            'C5 Vertebra': ['C4 Vertebra', 'C6 Vertebra'],
            'C6 Vertebra': ['C5 Vertebra', 'C7 Vertebra'],
            'C7 Vertebra': ['C6 Vertebra', 'T1 Vertebra'],
            'T1 Vertebra': ['C7 Vertebra', 'T2 Vertebra', 'True Ribs'],
            'T2 Vertebra': ['T1 Vertebra', 'T3 Vertebra', 'True Ribs'],
            'T3 Vertebra': ['T2 Vertebra', 'T4 Vertebra', 'True Ribs'],
            'T4 Vertebra': ['T3 Vertebra', 'T5 Vertebra', 'True Ribs'],
            'T5 Vertebra': ['T4 Vertebra', 'T6 Vertebra', 'True Ribs'],
            'T6 Vertebra': ['T5 Vertebra', 'T7 Vertebra', 'True Ribs'],
            'T7 Vertebra': ['T6 Vertebra', 'T8 Vertebra', 'True Ribs'],
            'T8 Vertebra': ['T7 Vertebra', 'T9 Vertebra', 'False Ribs'],
            'T9 Vertebra': ['T8 Vertebra', 'T10 Vertebra', 'False Ribs'],
            'T10 Vertebra': ['T9 Vertebra', 'T11 Vertebra', 'False Ribs'],
            'T11 Vertebra': ['T10 Vertebra', 'T12 Vertebra', 'False Ribs'],
            'T12 Vertebra': ['T11 Vertebra', 'L1 Vertebra', 'False Ribs'],
            'L1 Vertebra': ['T12 Vertebra', 'L2 Vertebra'],
            'L2 Vertebra': ['L1 Vertebra', 'L3 Vertebra'],
            'L3 Vertebra': ['L2 Vertebra', 'L4 Vertebra'],
            'L4 Vertebra': ['L3 Vertebra', 'L5 Vertebra'],
            'L5 Vertebra': ['L4 Vertebra', 'Sacrum'],
            'Sacrum': ['L5 Vertebra', 'Ilium', 'Ischium'],
            
            // ===== RIBS & STERNUM =====
            'True Ribs': ['T1 Vertebra', 'T2 Vertebra', 'T3 Vertebra', 'T4 Vertebra', 'T5 Vertebra', 'T6 Vertebra', 'T7 Vertebra', 'Sternum'],
            'False Ribs': ['T8 Vertebra', 'T9 Vertebra', 'T10 Vertebra', 'T11 Vertebra', 'T12 Vertebra'],
            'Sternum': ['True Ribs', 'Clavicle'],
            
            // ===== SHOULDER & ARM =====
            'Clavicle': ['Sternum', 'Scapula'],
            'Scapula': ['Clavicle', 'Humerus'],
            'Humerus': ['Scapula', 'Radius', 'Ulna'],
            'Radius': ['Humerus', 'Ulna', 'Scaphoid', 'Lunate'],
            'Ulna': ['Humerus', 'Radius', 'Triquetrum', 'Pisiform'],
            
            // ===== HAND - CARPALS =====
            'Scaphoid': ['Radius', 'Lunate', 'Capitate', 'Trapezium', 'Trapezoid'],
            'Lunate': ['Radius', 'Scaphoid', 'Triquetrum', 'Capitate', 'Hamate'],
            'Triquetrum': ['Ulna', 'Lunate', 'Pisiform', 'Hamate'],
            'Pisiform': ['Ulna', 'Triquetrum'],
            'Trapezium': ['Scaphoid', 'Trapezoid', 'Metacarpal I'],
            'Trapezoid': ['Scaphoid', 'Trapezium', 'Capitate', 'Metacarpal II'],
            'Capitate': ['Scaphoid', 'Lunate', 'Trapezoid', 'Hamate', 'Metacarpal II', 'Metacarpal III'],
            'Hamate': ['Lunate', 'Triquetrum', 'Capitate', 'Metacarpal IV', 'Metacarpal V'],
            
            // ===== HAND - METACARPALS =====
            'Metacarpal I': ['Trapezium', 'Proximal Phalanx I'],
            'Metacarpal II': ['Trapezoid', 'Capitate', 'Proximal Phalanx II'],
            'Metacarpal III': ['Capitate', 'Proximal Phalanx III'],
            'Metacarpal IV': ['Hamate', 'Proximal Phalanx IV'],
            'Metacarpal V': ['Hamate', 'Proximal Phalanx V'],
            
            // ===== HAND - PHALANGES (Thumb has 2, Fingers have 3 each) =====
            'Proximal Phalanx I': ['Metacarpal I', 'Distal Phalanx I'],
            'Distal Phalanx I': ['Proximal Phalanx I'],
            'Proximal Phalanx II': ['Metacarpal II', 'Middle Phalanx II'],
            'Middle Phalanx II': ['Proximal Phalanx II', 'Distal Phalanx II'],
            'Distal Phalanx II': ['Middle Phalanx II'],
            'Proximal Phalanx III': ['Metacarpal III', 'Middle Phalanx III'],
            'Middle Phalanx III': ['Proximal Phalanx III', 'Distal Phalanx III'],
            'Distal Phalanx III': ['Middle Phalanx III'],
            'Proximal Phalanx IV': ['Metacarpal IV', 'Middle Phalanx IV'],
            'Middle Phalanx IV': ['Proximal Phalanx IV', 'Distal Phalanx IV'],
            'Distal Phalanx IV': ['Middle Phalanx IV'],
            'Proximal Phalanx V': ['Metacarpal V', 'Middle Phalanx V'],
            'Middle Phalanx V': ['Proximal Phalanx V', 'Distal Phalanx V'],
            'Distal Phalanx V': ['Middle Phalanx V'],
            
            // ===== PELVIS =====
            'Ilium': ['Sacrum', 'Ischium', 'Pubis', 'Femur'],
            'Ischium': ['Sacrum', 'Ilium', 'Pubis', 'Femur'],
            'Pubis': ['Ilium', 'Ischium'],
            
            // ===== LEG =====
            'Femur': ['Ilium', 'Ischium', 'Patella', 'Tibia'],
            'Patella': ['Femur', 'Tibia'],
            'Tibia': ['Femur', 'Patella', 'Fibula', 'Talus'],
            'Fibula': ['Tibia', 'Talus'],
            
            // ===== FOOT - TARSALS =====
            'Talus': ['Tibia', 'Fibula', 'Calcaneus', 'Navicular'],
            'Calcaneus': ['Talus', 'Cuboid'],
            'Navicular': ['Talus', 'Medial Cuneiform', 'Intermediate Cuneiform', 'Lateral Cuneiform'],
            'Medial Cuneiform': ['Navicular', 'Intermediate Cuneiform', 'Metatarsal I', 'Metatarsal II'],
            'Intermediate Cuneiform': ['Navicular', 'Medial Cuneiform', 'Lateral Cuneiform', 'Metatarsal II'],
            'Lateral Cuneiform': ['Navicular', 'Intermediate Cuneiform', 'Cuboid', 'Metatarsal III', 'Metatarsal IV'],
            'Cuboid': ['Calcaneus', 'Lateral Cuneiform', 'Metatarsal IV', 'Metatarsal V'],
            
            // ===== FOOT - METATARSALS =====
            'Metatarsal I': ['Medial Cuneiform', 'Proximal Phalanx I (Foot)'],
            'Metatarsal II': ['Medial Cuneiform', 'Intermediate Cuneiform', 'Proximal Phalanx II (Foot)'],
            'Metatarsal III': ['Lateral Cuneiform', 'Proximal Phalanx III (Foot)'],
            'Metatarsal IV': ['Lateral Cuneiform', 'Cuboid', 'Proximal Phalanx IV (Foot)'],
            'Metatarsal V': ['Cuboid', 'Proximal Phalanx V (Foot)'],
            
            // ===== FOOT - PHALANGES (Big toe has 2, other toes have 3 each) =====
            'Proximal Phalanx I (Foot)': ['Metatarsal I', 'Distal Phalanx I (Foot)'],
            'Distal Phalanx I (Foot)': ['Proximal Phalanx I (Foot)'],
            'Proximal Phalanx II (Foot)': ['Metatarsal II', 'Middle Phalanx II (Foot)'],
            'Middle Phalanx II (Foot)': ['Proximal Phalanx II (Foot)', 'Distal Phalanx II (Foot)'],
            'Distal Phalanx II (Foot)': ['Middle Phalanx II (Foot)'],
            'Proximal Phalanx III (Foot)': ['Metatarsal III', 'Middle Phalanx III (Foot)'],
            'Middle Phalanx III (Foot)': ['Proximal Phalanx III (Foot)', 'Distal Phalanx III (Foot)'],
            'Distal Phalanx III (Foot)': ['Middle Phalanx III (Foot)'],
            'Proximal Phalanx IV (Foot)': ['Metatarsal IV', 'Middle Phalanx IV (Foot)'],
            'Middle Phalanx IV (Foot)': ['Proximal Phalanx IV (Foot)', 'Distal Phalanx IV (Foot)'],
            'Distal Phalanx IV (Foot)': ['Middle Phalanx IV (Foot)'],
            'Proximal Phalanx V (Foot)': ['Metatarsal V', 'Middle Phalanx V (Foot)'],
            'Middle Phalanx V (Foot)': ['Proximal Phalanx V (Foot)', 'Distal Phalanx V (Foot)'],
            'Distal Phalanx V (Foot)': ['Middle Phalanx V (Foot)']
        };

        // Define anatomically paired bones that should display side by side
        const TWIN_BONES = {
            'Radius': 'Ulna',
            'Ulna': 'Radius',
            'Tibia': 'Fibula',
            'Fibula': 'Tibia',
            'Talus': 'Calcaneus',
            'Calcaneus': 'Talus',
            'Ilium': 'Ischium',
            'Ischium': 'Ilium'
        };

        // Helper to check if two bones are twins
        const areTwins = (bone1, bone2) => {
            return TWIN_BONES[bone1] === bone2 || TWIN_BONES[bone2] === bone1;
        };

        const MAPPING_3D = {
            // Skull bones
            "Frontal Bone": "Frontal", "Parietal Bone": "Parietal", "Occipital Bone": "Occipital",
            "Temporal Bone": "Temporal", "Sphenoid Bone": "Sphenoid", "Ethmoid Bone": "Ethmoid",
            "Nasal Bone": "Nasal", "Lacrimal Bone": "Lacrimal", "Zygomatic Bone": "Zygomatic",
            "Maxilla": "Maxilla", "Palatine Bone": "Palatine", "Vomer": "Vomer",
            "Inferior Nasal Concha": "Concha", "Mandible": "Mandible",
            
            // Spine - individual vertebrae map to their specific names
            "Atlas (C1)": "Atlas", "Axis (C2)": "Axis",
            "C3 Vertebra": "Cervical", "C4 Vertebra": "Cervical", "C5 Vertebra": "Cervical",
            "C6 Vertebra": "Cervical", "C7 Vertebra": "Cervical",
            "T1 Vertebra": "Thoracic", "T2 Vertebra": "Thoracic", "T3 Vertebra": "Thoracic",
            "T4 Vertebra": "Thoracic", "T5 Vertebra": "Thoracic", "T6 Vertebra": "Thoracic",
            "T7 Vertebra": "Thoracic", "T8 Vertebra": "Thoracic", "T9 Vertebra": "Thoracic",
            "T10 Vertebra": "Thoracic", "T11 Vertebra": "Thoracic", "T12 Vertebra": "Thoracic",
            "L1 Vertebra": "Lumbar", "L2 Vertebra": "Lumbar", "L3 Vertebra": "Lumbar",
            "L4 Vertebra": "Lumbar", "L5 Vertebra": "Lumbar",
            "Sacrum": "Sacrum",
            
            // Ribs & sternum
            "True Ribs": "Rib_", "False Ribs": "Rib_",
            "Sternum": "sternum",
            
            // Upper limb
            "Clavicle": "Clavicl", "Scapula": "Scapula",
            "Humerus": "Humerus", "Radius": "Radius", "Ulna": "Ulna",
            
            // Hand - carpals (individual bones)
            "Scaphoid": "Scaphoid", "Lunate": "Lunate", "Triquetrum": "Triquetrum",
            "Pisiform": "Pisiform", "Trapezium": "Trapezium", "Trapezoid": "Trapezoid",
            "Capitate": "Capitate", "Hamate": "Hamate",
            
            // Hand - metacarpals
            "Metacarpal I": "1st_metacarpal", "Metacarpal II": "2nd_metacarpal",
            "Metacarpal III": "3rd_metacarpal", "Metacarpal IV": "4th_metacarpal",
            "Metacarpal V": "5th_metacarpal",
            
            // Hand - phalanges (will need special handling for specific digits)
            "Proximal Phalanx I": "phalanx_of_1st_finger", "Distal Phalanx I": "phalanx_of_1st_finger",
            "Proximal Phalanx II": "phalanx_of_2d_finger", "Middle Phalanx II": "phalanx_of_2d_finger", "Distal Phalanx II": "phalanx_of_2d_finger",
            "Proximal Phalanx III": "phalanx_of_3d_finger", "Middle Phalanx III": "phalanx_of_3d_finger", "Distal Phalanx III": "phalanx_of_3d_finger",
            "Proximal Phalanx IV": "phalanx_of_4th_finger", "Middle Phalanx IV": "phalanx_of_4th_finger", "Distal Phalanx IV": "phalanx_of_4th_finger",
            "Proximal Phalanx V": "phalanx_of_5th_finger", "Middle Phalanx V": "phalanx_of_5th_finger", "Distal Phalanx V": "phalanx_of_5th_finger",
            
            // Pelvis - all three map to same model parts
            "Ilium": "Ilium", "Ischium": "Ischium", "Pubis": "Pubis",
            
            // Lower limb
            "Femur": "Femur", "Patella": "Patellar",
            "Tibia": "Tibia", "Fibula": "Fibula",
            
            // Foot - tarsals
            "Talus": "Talus", "Calcaneus": "Calcaneus", "Navicular": "Navicular_boner",
            "Cuboid": "Cuboid_boner",
            "Medial Cuneiform": "Medial_cuneiform", "Intermediate Cuneiform": "Intermediate_cuneiform",
            "Lateral Cuneiform": "Lateral_cuneiform",
            
            // Foot - metatarsals
            "Metatarsal I": "First_metatarsal", "Metatarsal II": "Second_metatarsal",
            "Metatarsal III": "Third_metatarsal", "Metatarsal IV": "Fourth_metatarsal",
            "Metatarsal V": "Fifth_metatarsal",
            
            // Foot - phalanges
            "Proximal Phalanx I (Foot)": "first_finger_of_foot", "Distal Phalanx I (Foot)": "first_finger_of_foot",
            "Proximal Phalanx II (Foot)": "second_finger_of_foot", "Middle Phalanx II (Foot)": "second_finger_of_foot", "Distal Phalanx II (Foot)": "second_finger_of_foot",
            "Proximal Phalanx III (Foot)": "third_finger_of_foot", "Middle Phalanx III (Foot)": "third_finger_of_foot", "Distal Phalanx III (Foot)": "third_finger_of_foot",
            "Proximal Phalanx IV (Foot)": "fourth_finger_of_foot", "Middle Phalanx IV (Foot)": "fourth_finger_of_foot", "Distal Phalanx IV (Foot)": "fourth_finger_of_foot",
            "Proximal Phalanx V (Foot)": "fifth_finger_of_foot", "Middle Phalanx V (Foot)": "fifth_finger_of_foot", "Distal Phalanx V (Foot)": "fifth_finger_of_foot"
        };

        const findShortestPath = (start, end) => {
            const queue = [[start]]; const visited = new Set([start]);
            while (queue.length > 0) {
                const path = queue.shift(); const current = path[path.length - 1];
                if (current === end) return path;
                for (const neighbor of (SKELETON_GRAPH[current] || [])) {
                    if (!visited.has(neighbor)) { visited.add(neighbor); queue.push([...path, neighbor]); }
                }
            }
            return null;
        };

        // Check if a bone is on ANY valid path from start to target
        const isOnValidPath = (bone, start, target) => {
            // Can we reach the bone from start?
            const pathToGuess = findShortestPath(start, bone);
            if (!pathToGuess) return false;
            
            // Can we reach target from the bone?
            const pathFromGuess = findShortestPath(bone, target);
            if (!pathFromGuess) return false;
            
            return true; // Valid path exists through this bone
        };

        // Check if we can reach target from start using only guessed bones
        const canReachTargetWithGuessed = (start, target, guessedBones, detourBones) => {
            const allGuessed = new Set([...guessedBones, ...detourBones, start]); // Include start as "guessed"
            
            // BFS using only guessed bones
            const queue = [start];
            const visited = new Set([start]);
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                if (current === target) return true; // Reached target!
                
                // Explore neighbors that have been guessed
                for (const neighbor of (SKELETON_GRAPH[current] || [])) {
                    if (!visited.has(neighbor) && allGuessed.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push(neighbor);
                    }
                }
            }
            
            return false; // Can't reach target with guessed bones
        };

        function App() {
            const [target, setTarget] = useState({ start: '', end: '', path: [] });
            const [chain, setChain] = useState([]);
            const [guessesLeft, setGuessesLeft] = useState(10);
            const [maxGuesses, setMaxGuesses] = useState(10);
            const [badGuesses, setBadGuesses] = useState([]); // Off any valid path
            const [detours, setDetours] = useState([]); // Valid but not on optimal path
            const [inputValue, setInputValue] = useState('');
            const [gameState, setGameState] = useState('playing');
            const [showReveal, setShowReveal] = useState(false);

            const initGame = useCallback(() => {
                const bones = Object.keys(SKELETON_GRAPH);
                let s, e, p;
                do {
                    s = bones[Math.floor(Math.random() * bones.length)];
                    e = bones[Math.floor(Math.random() * bones.length)];
                    p = findShortestPath(s, e);
                } while (!p || p.length < 4 || p.length > 8 || s === e);

                setTarget({ start: s, end: e, path: p });
                // Initialize chain with all bones in correct order, mark first as guessed
                const initialChain = p.map((bone, idx) => ({
                    bone,
                    type: idx === 0 ? 'start' : 'path',
                    guessed: idx === 0 // Only start is guessed initially
                }));
                setChain(initialChain);
                // Guesses = path length (excluding start which is free) + 3 extra attempts
                const optimalGuesses = p.length - 1; // -1 because start is free
                const totalGuesses = optimalGuesses + 3;
                setGuessesLeft(totalGuesses);
                setMaxGuesses(totalGuesses); 
                setBadGuesses([]);
                setDetours([]); // Reset detours
                setInputValue(''); 
                setGameState('playing');
                setShowReveal(false);
                if (window.reset3D) window.reset3D();
            }, []);

            useEffect(() => { initGame(); }, [initGame]);

            useEffect(() => {
                const highlights = [];
                
                // If revealing, show the full correct path with missing links highlighted
                if (showReveal && gameState === 'lost') {
                    chain.forEach((item, idx) => {
                        const isLastBone = idx === chain.length - 1;
                        if (item.guessed && !isLastBone) {
                            highlights.push({ name: item.bone, type: item.type });
                        } else if (!item.guessed && !isLastBone) {
                            highlights.push({ name: item.bone, type: 'reveal' });
                        } else if (isLastBone) {
                            highlights.push({ name: item.bone, type: 'end' });
                        }
                    });
                } else {
                    // Normal game state: show guessed bones
                    chain.forEach((item, idx) => {
                        const isLastBone = idx === chain.length - 1;
                        if (item.guessed && !isLastBone) {
                            highlights.push({ name: item.bone, type: item.type });
                        } else if (isLastBone) {
                            highlights.push({ name: item.bone, type: 'end' });
                        }
                    });
                    
                    // Show detours (valid but suboptimal)
                    detours.forEach(g => highlights.push({ name: g, type: 'detour' }));
                    
                    // Show bad guesses
                    badGuesses.forEach(g => highlights.push({ name: g, type: 'bad' }));
                }
                
                if (window.update3D) window.update3D(highlights);
            }, [chain, badGuesses, detours, showReveal, gameState]);

            const submitGuess = (guess) => {
                if (gameState !== 'playing' || guess === target.end) return;
                
                // Check if guess is on the optimal (shortest) path
                const isOnOptimalPath = target.path.includes(guess);
                
                if (isOnOptimalPath) {
                    // OPTIMAL PATH: On the shortest route ‚úì
                    setGuessesLeft(prev => prev - 1);
                    setChain(prev => prev.map(item => 
                        item.bone === guess ? { ...item, guessed: true } : item
                    ));
                    
                    // Check win condition: can we reach target with guessed bones?
                    const updatedChain = chain.map(item => 
                        item.bone === guess ? { ...item, guessed: true } : item
                    );
                    const guessedOptimal = updatedChain.filter(c => c.guessed).map(c => c.bone);
                    
                    if (canReachTargetWithGuessed(target.start, target.end, guessedOptimal, detours)) {
                        setGameState('won');
                        return;
                    }
                } else {
                    // Not on optimal path - check if it's on ANY valid path
                    const isValidDetour = isOnValidPath(guess, target.start, target.end);
                    
                    if (isValidDetour) {
                        // SUBOPTIMAL PATH: Valid but longer route ‚ö†
                        const newDetours = [...new Set([guess, ...detours])];
                        setDetours(newDetours);
                        setGuessesLeft(prev => prev - 1);
                        
                        // Check win condition with detours too!
                        const guessedOptimal = chain.filter(c => c.guessed).map(c => c.bone);
                        if (canReachTargetWithGuessed(target.start, target.end, guessedOptimal, newDetours)) {
                            setGameState('won');
                            return;
                        }
                    } else {
                        // FAILURE: Not on any valid path ‚úó
                        setBadGuesses(prev => [...new Set([guess, ...prev])]);
                        setGuessesLeft(prev => prev - 1);
                    }
                }
                
                if (guessesLeft <= 1) setGameState('lost');
                setInputValue('');
            };

            const suggestions = useMemo(() => {
                if (!inputValue) return [];
                const guessedBones = chain.filter(c => c.guessed).map(c => c.bone);
                return Object.keys(SKELETON_GRAPH)
                    .filter(b => 
                        b.toLowerCase().includes(inputValue.toLowerCase()) && 
                        !guessedBones.includes(b) && 
                        b !== target.end &&
                        !badGuesses.includes(b) &&
                        !detours.includes(b) // Also exclude detours
                    ).slice(0, 5);
            }, [inputValue, chain, target, badGuesses, detours]);

            return (
                <div className="sidebar p-6">
                    <header className="mb-4">
                        <h1 className="text-3xl font-black text-white tracking-tighter uppercase">Anatomle</h1>
                        <div className="flex justify-between items-center border-b border-slate-700 pb-2">
                            <span className="text-[9px] text-slate-500 tracking-[0.3em] uppercase">Clinical Pro v18.7</span>
                            <span className={`text-xs font-bold ${guessesLeft < 4 ? 'text-red-400' : 'text-emerald-400'}`}>{guessesLeft} Guesses</span>
                        </div>
                    </header>

                    <div className="bg-slate-800/40 p-3 border border-slate-700 mb-4 rounded flex justify-between">
                        <div>
                            <p className="text-[8px] text-slate-500 uppercase font-bold">Start</p>
                            <p className="text-[10px] font-bold uppercase text-emerald-400">{target.start}</p>
                        </div>
                        <div className="text-right">
                            <p className="text-[8px] text-slate-500 uppercase font-bold">Target</p>
                            <p className="text-[10px] font-bold uppercase text-amber-400">{target.end}</p>
                        </div>
                    </div>

                    {/* Detours Section - Valid but not optimal */}
                    {detours.length > 0 && (
                        <div className="mb-4">
                            <p className="text-[8px] text-amber-400 uppercase font-bold mb-2 tracking-wider">‚ö†Ô∏è Longer Routes</p>
                            <div className="flex flex-wrap gap-1.5">
                                {detours.map((g, i) => (
                                    <div key={i} className="text-[9px] font-bold text-amber-400 bg-amber-900/30 px-2.5 py-1 border border-amber-800/40 uppercase tracking-tight rounded">
                                        {g}
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Failed Guesses Section - Horizontal */}
                    {badGuesses.length > 0 && (
                        <div className="mb-4">
                            <p className="text-[8px] text-red-400 uppercase font-bold mb-2 tracking-wider">‚ùå Failed Attempts</p>
                            <div className="flex flex-wrap gap-1.5">
                                {badGuesses.map((g, i) => (
                                    <div key={i} className="failure-item text-[9px] font-bold text-red-400 bg-red-900/30 px-2.5 py-1 border border-red-800/40 uppercase tracking-tight rounded">
                                        {g}
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Correct Path Chain */}
                    <div className="flex-1 overflow-y-auto custom-scrollbar space-y-1 mb-4">
                        <p className="text-[8px] text-slate-500 uppercase font-bold mb-2 tracking-wider">üß¨ Your Path</p>
                        {chain.map((item, idx) => {
                            const isLastBone = idx === chain.length - 1;
                            const isMissing = showReveal && gameState === 'lost' && !item.guessed && !isLastBone;
                            
                            // Check if this bone has a twin
                            const twinName = TWIN_BONES[item.bone];
                            const hasTwin = !!twinName;
                            
                            // Check if next item is also a twin pair member (skip duplicate rendering)
                            const nextItem = chain[idx + 1];
                            const isTwinWithNext = nextItem && areTwins(item.bone, nextItem.bone);
                            const prevItem = chain[idx - 1];
                            const isTwinWithPrev = prevItem && areTwins(item.bone, prevItem.bone);
                            if (isTwinWithPrev) return null; // Skip if we already rendered this as part of previous twin
                            
                            // Find twin bone status (might be in chain, detours, or not guessed)
                            let twinItem = null;
                            if (hasTwin && !isTwinWithNext) {
                                // Twin is not next to us in chain, check if it exists elsewhere
                                const twinInChain = chain.find(c => c.bone === twinName);
                                const twinIsDetour = detours.includes(twinName);
                                
                                if (twinInChain) {
                                    twinItem = twinInChain;
                                } else if (twinIsDetour) {
                                    // Twin was guessed as a detour - show it
                                    twinItem = { bone: twinName, type: 'detour', guessed: true };
                                }
                            }
                            
                            // Single bone render function
                            const renderBone = (boneItem, isOptimalPath = true, isInPair = false) => {
                                const boneIsLastBone = boneItem.bone === target.end;
                                const boneIsMissing = showReveal && gameState === 'lost' && !boneItem.guessed && !boneIsLastBone;
                                const isDetourBone = boneItem.type === 'detour' || detours.includes(boneItem.bone);
                                
                                return (
                                    <div className={`p-2 border transition-all ${isInPair ? 'flex-1' : ''} ${
                                        !boneItem.guessed && !boneIsLastBone && !showReveal
                                            ? 'border-dashed border-slate-700/40 opacity-20' 
                                            : boneIsMissing 
                                                ? 'bg-fuchsia-900/20 border-fuchsia-700/40 shadow-sm'
                                                : isDetourBone && boneItem.guessed
                                                    ? 'bg-orange-900/20 border-orange-700/40 shadow-sm'
                                                : boneIsLastBone
                                                    ? 'bg-amber-900/20 border-amber-700/40 shadow-sm'
                                                    : 'bg-slate-800 border-slate-600 shadow-sm'
                                    }`}>
                                        <div className="flex justify-between items-center text-[9px] font-black uppercase tracking-widest">
                                            <span className={
                                                boneItem.type === 'start' ? 'text-emerald-400' : 
                                                boneIsLastBone ? 'text-amber-400' :
                                                boneIsMissing ? 'text-fuchsia-400' :
                                                isDetourBone && boneItem.guessed ? 'text-orange-400' :
                                                'text-blue-400'
                                            }>
                                                {showReveal && gameState === 'lost' ? boneItem.bone : 
                                                 !boneItem.guessed && !boneIsLastBone ? '???' : boneItem.bone}
                                            </span>
                                            <span>
                                                {boneItem.type === 'start' ? 'üìç' : 
                                                 boneIsLastBone ? 'üéØ' :
                                                 boneIsMissing ? 'üîó' :
                                                 isDetourBone && boneItem.guessed ? '‚ö†Ô∏è' : 'üß¨'}
                                            </span>
                                        </div>
                                        {boneIsMissing && (
                                            <p className="text-[7px] text-fuchsia-400 mt-1 tracking-wider">MISSING LINK</p>
                                        )}
                                    </div>
                                );
                            };
                            
                            // Render twin bones side by side if twin exists
                            if (isTwinWithNext) {
                                return (
                                    <div key={idx} className="flex gap-1">
                                        {renderBone(item, true, true)}
                                        {renderBone(nextItem, true, true)}
                                    </div>
                                );
                            } else if (twinItem) {
                                // Twin exists elsewhere - render together
                                return (
                                    <div key={idx} className="flex gap-1">
                                        {renderBone(item, true, true)}
                                        {renderBone(twinItem, false, true)}
                                    </div>
                                );
                            }
                            
                            // Render single bone
                            return <div key={idx}>{renderBone(item, true, false)}</div>;
                        })}
                    </div>

                    <div className="mt-auto space-y-3">
                        <div className="relative">
                            <input 
                                className="w-full bg-slate-900 border border-slate-700 p-3 text-white outline-none focus:border-blue-500 text-xs italic" 
                                placeholder="Identify next structure..." 
                                value={inputValue} 
                                onChange={e => setInputValue(e.target.value)}
                                disabled={gameState !== 'playing'}
                            />
                            {suggestions.length > 0 && (
                                <div className="absolute bottom-full left-0 w-full bg-slate-900 border border-slate-700 z-[60] shadow-2xl">
                                    {suggestions.map(s => (
                                        <div 
                                            key={s} 
                                            onClick={() => submitGuess(s)} 
                                            className="suggestion-item p-3 text-[10px] uppercase font-black transition-all"
                                        >
                                            {s}
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>

                        <button 
                            onClick={initGame} 
                            className="w-full py-3 bg-white text-black text-[10px] font-black uppercase tracking-widest hover:bg-emerald-400 hover:text-white transition-all"
                        >
                            Next Case
                        </button>
                    </div>

                    {gameState !== 'playing' && !showReveal && (
                        <div className={`fixed inset-0 z-[100] flex flex-col items-center justify-center backdrop-blur-xl ${gameState === 'won' ? 'victory-bg' : 'loss-bg'}`}>
                            <div className="text-center p-12 bg-slate-950/90 border border-white/10 rounded-3xl max-w-md">
                                <h2 className="text-5xl font-black text-white mb-2 tracking-tighter uppercase">
                                    {gameState === 'won' 
                                        ? (detours.length === 0 ? '‚úì Perfect Path' : '‚úì Path Complete')
                                        : '‚úó Flatline'}
                                </h2>
                                <p className="text-slate-400 text-sm mb-6">
                                    {gameState === 'won' 
                                        ? (detours.length === 0 
                                            ? `Optimal route! ${maxGuesses - guessesLeft}/${maxGuesses} guesses used.`
                                            : `Valid path found with ${detours.length} detour${detours.length !== 1 ? 's' : ''}. ${maxGuesses - guessesLeft}/${maxGuesses} guesses used.`)
                                        : `Path not found. ${badGuesses.length} failed attempt${badGuesses.length !== 1 ? 's' : ''}.`
                                    }
                                </p>
                                
                                {gameState === 'lost' && (
                                    <div className="mb-6">
                                        <button 
                                            onClick={() => setShowReveal(!showReveal)}
                                            className="px-6 py-3 bg-fuchsia-500 text-white font-black text-xs uppercase hover:bg-fuchsia-400 transition-all"
                                        >
                                            {showReveal ? '‚úó Hide' : 'üëÅÔ∏è Reveal'} Correct Path
                                        </button>
                                        <p className="text-[10px] text-slate-500 mt-2">
                                            {showReveal ? 'Missing links shown in magenta' : 'See what you missed'}
                                        </p>
                                    </div>
                                )}
                                
                                <button 
                                    onClick={initGame} 
                                    className="px-12 py-4 bg-white text-black font-black text-xs uppercase hover:scale-105 transition-transform"
                                >
                                    Restart Diagnostic
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const init3D = () => {
            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Store controls so we can update them
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false; // Don't pan up/down
            controls.minDistance = 1; // Min zoom
            controls.maxDistance = 10; // Max zoom
            controls.maxPolarAngle = Math.PI; // Can rotate fully
            
            camera.position.set(0, 1.2, 5);
            
            // Better lighting for visibility
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);

            const draco = new THREE.DRACOLoader();
            draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
            const loader = new THREE.GLTFLoader();
            loader.setDRACOLoader(draco);

            let skeleton;
            loader.load('./overview-skeleton.glb', (gltf) => {
                skeleton = gltf.scene;
                scene.add(skeleton);
                
                // Calculate bounding box to center the model
                const box = new THREE.Box3().setFromObject(skeleton);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                // Set controls target to center of model
                controls.target.copy(center);
                controls.update();
                
                // Adjust camera to see whole model
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                cameraZ *= 1.5; // Add some padding
                
                camera.position.set(center.x, center.y, center.z + cameraZ);
                camera.lookAt(center);
                controls.update();
                
                window.reset3D();
            });

            window.reset3D = () => {
                if (!skeleton) return;
                skeleton.traverse(node => {
                    if (node.isMesh) {
                        node.material = new THREE.MeshStandardMaterial({ 
                            color: 0x475569, 
                            transparent: true, 
                            opacity: 0.25, 
                            wireframe: false 
                        });
                    }
                });
            };

            window.update3D = (bones) => {
                if (!skeleton) return;
                skeleton.traverse(node => {
                    if (node.isMesh) {
                        const match = bones.find(b => {
                            const key = MAPPING_3D[b.name];
                            if (!key) return false;
                            
                            // Special case: differentiate hand vs foot phalanges
                            if (b.name === "Phalanges (Hand)") {
                                return node.name.includes("phalanx") && !node.name.includes("footr");
                            }
                            if (b.name === "Phalanges (Foot)") {
                                return node.name.includes("phalanx") && node.name.includes("footr");
                            }
                            
                            // Special case: Hip bones all light up together (fused in 3D model)
                            if (b.name === "Ilium" || b.name === "Ischium" || b.name === "Pubis") {
                                const hipParts = ["Ilium", "Ischium", "Pubis"];
                                return hipParts.some(part => node.name.includes(part));
                            }
                            
                            // Default: standard includes check
                            return node.name.includes(key);
                        });
                        
                        if (match) {
                            let col = 0x3b82f6; // Blue for correct guesses
                            let emissiveInt = 0.5;
                            
                            if (match.type === 'start') col = 0x10b981; // Green for start
                            if (match.type === 'end') col = 0xf59e0b; // Amber for end
                            if (match.type === 'detour') {
                                col = 0xf97316; // Orange for suboptimal/longer routes
                                emissiveInt = 0.6;
                            }
                            if (match.type === 'bad') { 
                                col = 0xef4444; // Red for failures
                                emissiveInt = 0.8;
                            }
                            if (match.type === 'reveal') {
                                col = 0xd946ef; // Fuchsia/Magenta for revealed missing bones
                                emissiveInt = 0.8;
                            }
                            
                            node.material = new THREE.MeshStandardMaterial({ 
                                color: col, 
                                emissive: col, 
                                emissiveIntensity: emissiveInt, 
                                transparent: false, 
                                opacity: 1 
                            });
                        } else {
                            // Reset to default gray
                            node.material = new THREE.MeshStandardMaterial({ 
                                color: 0x475569, 
                                transparent: true, 
                                opacity: 0.25, 
                                wireframe: false 
                            });
                        }
                    }
                });
            };
            
            const animate = () => { 
                requestAnimationFrame(animate);
                controls.update(); // Required for damping
                renderer.render(scene, camera); 
            };
            animate();
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        init3D();
    </script>
</body>
</html>
