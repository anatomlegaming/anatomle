<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ANATOMLE | Skull</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- UI Template -->
    <script src="../js/ui/floodFillUI.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;700&display=swap');
        * { box-sizing: border-box; }
        body { font-family: 'EB Garamond', serif; background: #0f172a; color: #d6d3d1; margin: 0; overflow: hidden; }
        #cv { position: fixed; top: 104px; left: 0; right: 280px; bottom: 64px; z-index: 10; background: linear-gradient(160deg, #1e293b 0%, #0f172a 100%); }
        .scr::-webkit-scrollbar { width: 3px; }
        .scr::-webkit-scrollbar-thumb { background: #334155; border-radius: 2px; }
        .shake { animation: shake .3s ease-in-out; }
        @keyframes shake { 0%,100%{transform:translateX(0)} 25%{transform:translateX(-4px)} 75%{transform:translateX(4px)} }
        .win-bg  { background: radial-gradient(circle, rgba(16,185,129,.2) 0%, rgba(5,10,20,.97) 100%); }
        .loss-bg { background: radial-gradient(circle, rgba(239,68,68,.2) 0%, rgba(5,10,20,.97) 100%); }
    </style>
</head>
<body>
<div id="cv"></div>
<div id="root"></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     GAME CONFIGURATION
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>
// â”€â”€ SKULL GRAPH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SKULL_GRAPH = {
    'Frontal Bone':          ['Parietal Bone','Sphenoid Bone','Ethmoid Bone','Nasal Bone','Lacrimal Bone','Zygomatic Bone','Maxilla'],
    'Parietal Bone':         ['Frontal Bone','Occipital Bone','Temporal Bone','Sphenoid Bone'],
    'Occipital Bone':        ['Parietal Bone','Temporal Bone','Sphenoid Bone'],
    'Temporal Bone':         ['Parietal Bone','Occipital Bone','Sphenoid Bone','Zygomatic Bone','Mandible'],
    'Sphenoid Bone':         ['Frontal Bone','Parietal Bone','Occipital Bone','Temporal Bone','Ethmoid Bone','Zygomatic Bone','Palatine Bone','Vomer'],
    'Ethmoid Bone':          ['Frontal Bone','Sphenoid Bone','Nasal Bone','Lacrimal Bone','Maxilla','Vomer','Inferior Nasal Concha'],
    'Nasal Bone':            ['Frontal Bone','Ethmoid Bone','Maxilla'],
    'Lacrimal Bone':         ['Frontal Bone','Ethmoid Bone','Maxilla'],
    'Zygomatic Bone':        ['Frontal Bone','Temporal Bone','Sphenoid Bone','Maxilla'],
    'Maxilla':               ['Frontal Bone','Ethmoid Bone','Nasal Bone','Lacrimal Bone','Zygomatic Bone','Palatine Bone','Vomer','Inferior Nasal Concha','Mandible'],
    'Palatine Bone':         ['Sphenoid Bone','Maxilla'],
    'Vomer':                 ['Sphenoid Bone','Ethmoid Bone','Maxilla'],
    'Inferior Nasal Concha': ['Ethmoid Bone','Maxilla'],
    'Mandible':              ['Temporal Bone','Maxilla'],
};

const SKULL_MESH_MAP = {
    'Frontal Bone':'Frontal','Parietal Bone':'Parietal','Occipital Bone':'Occipital',
    'Temporal Bone':'Temporal','Sphenoid Bone':'Sphenoid','Ethmoid Bone':'Ethmoid',
    'Nasal Bone':'Nasal_boner','Lacrimal Bone':'Lacrimal_boner','Zygomatic Bone':'Zygomatic',
    'Maxilla':'Maxilla','Palatine Bone':'Palatine','Vomer':'Vomer',
    'Inferior Nasal Concha':'Inferior_nasal_concha_boner','Mandible':'Mandible'
};

const SKULL_MESH_KEYS = Object.values(SKULL_MESH_MAP);
const ALL_BONES = Object.keys(SKULL_GRAPH);
const TOTAL = ALL_BONES.length; // 14
</script>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     3D ENGINE
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script src="../js/3d/skullEngine.js"></script>
<!-- OR inline if preferred: -->
<script>
var _sk = null;

function isSkull(n) { for(var i=0;i<SKULL_MESH_KEYS.length;i++) if(n.indexOf(SKULL_MESH_KEYS[i])!==-1) return true; return false; }

window.update3D = function(bones) {
    if (!_sk) return;
    _sk.traverse(function(node) {
        if (!node.isMesh || !isSkull(node.name)) { node.visible = false; return; }
        node.visible = true;
        var m = null;
        for (var i=0;i<bones.length;i++) {
            var k = SKULL_MESH_MAP[bones[i].name];
            if (k && node.name.indexOf(k)!==-1) { m = bones[i]; break; }
        }
        if (m) {
            var c=0x3b82f6, e=0.5;
            if (m.type==='start') { c=0x10b981; e=0.6; }
            if (m.type==='bad')   { c=0xef4444; e=0.8; }
            if (m.type==='reveal'){ c=0xd946ef; e=0.8; }
            node.material = new THREE.MeshStandardMaterial({color:c,emissive:c,emissiveIntensity:e});
        } else {
            node.material = new THREE.MeshStandardMaterial({color:0x334155,transparent:true,opacity:0.3});
        }
    });
};

window.reset3D = function() {
    if (!_sk) return;
    _sk.traverse(function(n) {
        if (!n.isMesh) return;
        if (isSkull(n.name)) { n.material=new THREE.MeshStandardMaterial({color:0x334155,transparent:true,opacity:0.3}); n.visible=true; }
        else n.visible=false;
    });
};

window.addEventListener('DOMContentLoaded', function() {
    var cont=document.getElementById('cv');
    var scene=new THREE.Scene();
    var cam=new THREE.PerspectiveCamera(45,cont.clientWidth/cont.clientHeight,0.1,1000);
    var renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
    renderer.setSize(cont.clientWidth,cont.clientHeight);
    cont.appendChild(renderer.domElement);

    var ctrl=new THREE.OrbitControls(cam,renderer.domElement);
    ctrl.enableDamping=true; ctrl.dampingFactor=0.05; ctrl.minDistance=0.3; ctrl.maxDistance=6; ctrl.maxPolarAngle=Math.PI; ctrl.enableZoom=false;

    // Cursor zoom
    renderer.domElement.addEventListener('wheel',function(e){
        e.preventDefault();
        var rect=renderer.domElement.getBoundingClientRect();
        var mouse=new THREE.Vector2(((e.clientX-rect.left)/rect.width)*2-1,-((e.clientY-rect.top)/rect.height)*2+1);
        var ray=new THREE.Raycaster(); ray.setFromCamera(mouse,cam);
        var t3d; if(_sk){var h=ray.intersectObjects([_sk],true);if(h.length)t3d=h[0].point.clone();}
        if(!t3d)t3d=ray.ray.at(cam.position.distanceTo(ctrl.target),new THREE.Vector3());
        var dir=new THREE.Vector3().subVectors(t3d,cam.position);
        var dist=cam.position.distanceTo(ctrl.target);
        var step=dir.length()*0.12;
        if(e.deltaY<0&&dist>ctrl.minDistance)cam.position.addScaledVector(dir.normalize(),step);
        else if(e.deltaY>0&&dist<ctrl.maxDistance)cam.position.addScaledVector(dir.normalize(),-step);
        ctrl.update();
    },{passive:false});

    scene.add(new THREE.AmbientLight(0xffffff,0.7));
    var dl=new THREE.DirectionalLight(0xffffff,0.8); dl.position.set(5,10,7.5); scene.add(dl);

    var draco=new THREE.DRACOLoader(); draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    var loader=new THREE.GLTFLoader(); loader.setDRACOLoader(draco);
    loader.load('../models/overview-skeleton.glb', function(gltf){
        _sk=gltf.scene; scene.add(_sk);
        var box=new THREE.Box3();
        _sk.traverse(function(n){if(n.isMesh&&isSkull(n.name))box.expandByObject(n);else if(n.isMesh)n.visible=false;});
        var center=box.getCenter(new THREE.Vector3());
        ctrl.target.copy(center);
        var fov=cam.fov*(Math.PI/180); var size=box.getSize(new THREE.Vector3()); var maxDim=Math.max(size.x,size.y,size.z);
        cam.position.set(center.x,center.y,center.z+Math.abs(maxDim/2/Math.tan(fov/2))*1.8);
        cam.lookAt(center); ctrl.update();
        window.reset3D();
    });
    function animate(){ requestAnimationFrame(animate); ctrl.update(); renderer.render(scene,cam); } animate();
    var ro=new ResizeObserver(function(){ cam.aspect=cont.clientWidth/cont.clientHeight; cam.updateProjectionMatrix(); renderer.setSize(cont.clientWidth,cont.clientHeight); }); ro.observe(cont);
});
</script>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     GAME LOGIC
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script type="text/babel">
const { useState, useEffect, useMemo, useCallback } = React;

function SkullGame() {
    // â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const [guessed, setGuessed] = useState(() => new Set());
    const [start,   setStart]   = useState('');
    const [bad,     setBad]     = useState([]);
    const [left,    setLeft]    = useState(0);
    const [max,     setMax]     = useState(0);
    const [input,   setInput]   = useState('');
    const [selIdx,  setSelIdx]  = useState(-1);
    const [phase,   setPhase]   = useState('playing');
    const [reveal,  setReveal]  = useState(false);

    // â”€â”€ GAME LOGIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const startNew = useCallback(() => {
        const s = ALL_BONES[Math.floor(Math.random() * ALL_BONES.length)];
        const total = (TOTAL - 1) + 4;
        setStart(s); setGuessed(new Set([s]));
        setBad([]); setLeft(total); setMax(total);
        setInput(''); setSelIdx(-1); setPhase('playing'); setReveal(false);
        try { window.reset3D && window.reset3D(); } catch(e) {}
    }, []);

    useEffect(() => { startNew(); }, []);

    // Bones adjacent to any guessed bone
    const frontier = useMemo(() => {
        const f = new Set();
        guessed.forEach(b => { (SKULL_GRAPH[b]||[]).forEach(n => { if (!guessed.has(n)) f.add(n); }); });
        return f;
    }, [guessed]);

    // Sync 3D
    useEffect(() => {
        const h = [];
        guessed.forEach(b => h.push({name:b, type: b===start ? 'start' : 'found'}));
        if (reveal && phase==='lost') ALL_BONES.forEach(b => { if (!guessed.has(b)) h.push({name:b,type:'reveal'}); });
        bad.forEach(b => h.push({name:b,type:'bad'}));
        try { window.update3D && window.update3D(h); } catch(e) {}
    }, [guessed, bad, start, reveal, phase]);

    // Suggestions
    const suggestions = useMemo(() => {
        if (!input.trim()) return [];
        return ALL_BONES.filter(b =>
            b.toLowerCase().includes(input.toLowerCase()) &&
            !guessed.has(b) && !bad.includes(b)
        ).slice(0, 7);
    }, [input, guessed, bad]);

    useEffect(() => { setSelIdx(-1); }, [suggestions.length]);

    const submit = useCallback((g) => {
        if (phase !== 'playing' || !g || !ALL_BONES.includes(g) || guessed.has(g)) return;
        const nl = left - 1; setLeft(nl);
        if (frontier.has(g)) {
            const ng = new Set(guessed); ng.add(g); setGuessed(ng);
            if (ng.size === TOTAL) { setPhase('won'); setInput(''); return; }
            if (nl <= 0) { setPhase('lost'); setInput(''); return; }
        } else {
            setBad(p => [...new Set([g, ...p])]);
            if (nl <= 0) { setPhase('lost'); setInput(''); return; }
        }
        setInput(''); setSelIdx(-1);
    }, [phase, guessed, frontier, left, bad]);

    // â”€â”€ UI HANDLERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const handleKey = (e) => {
        if (e.key === 'ArrowDown') { e.preventDefault(); setSelIdx(i => Math.min(i+1, suggestions.length-1)); }
        else if (e.key === 'ArrowUp') { e.preventDefault(); setSelIdx(i => Math.max(i-1, 0)); }
        else if (e.key === 'Enter') {
            if (selIdx >= 0 && suggestions[selIdx]) submit(suggestions[selIdx]);
            else if (suggestions.length === 1) submit(suggestions[0]);
        }
        else if (e.key === 'Escape') { setInput(''); setSelIdx(-1); }
    };

    // â”€â”€ RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const uiState = {
        start, total: TOTAL, guessed, bad, left, max,
        input, selIdx, phase, reveal, suggestions
    };

    const uiHandlers = {
        onInputChange: e => setInput(e.target.value),
        onKeyDown: handleKey,
        onSubmit: submit,
        onNewGame: startNew,
        onReveal: () => setReveal(true)
    };

    return (
        <window.FloodFillUI
            gameTitle="ðŸ’€ Skull"
            accentColor="#f59e0b"
            state={uiState}
            handlers={uiHandlers}
        />
    );
}

ReactDOM.createRoot(document.getElementById('root')).render(<SkullGame />);
</script>
</body>
</html>
