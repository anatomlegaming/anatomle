<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ANATOMLE | Hand</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;700&display=swap');
        * { box-sizing: border-box; }
        body { font-family: 'EB Garamond', serif; background: #0f172a; color: #d6d3d1; margin: 0; overflow: hidden; }
        #cv { position: fixed; top: 104px; left: 0; right: 280px; bottom: 64px; z-index: 10; background: linear-gradient(160deg, #1e293b 0%, #0f172a 100%); }
        .scr::-webkit-scrollbar { width: 3px; }
        .scr::-webkit-scrollbar-thumb { background: #334155; border-radius: 2px; }
        .shake { animation: shake .3s ease-in-out; }
        @keyframes shake { 0%,100%{transform:translateX(0)} 25%{transform:translateX(-4px)} 75%{transform:translateX(4px)} }
        .win-bg  { background: radial-gradient(circle, rgba(16,185,129,.2) 0%, rgba(5,10,20,.97) 100%); }
        .loss-bg { background: radial-gradient(circle, rgba(239,68,68,.2) 0%, rgba(5,10,20,.97) 100%); }
    </style>
</head>
<body>
<div id="cv"></div>
<div id="root"></div>

<script>
const HAND_GRAPH = {
    'Radius':['Ulna','Scaphoid','Lunate'],'Ulna':['Radius','Triquetrum','Pisiform'],
    'Scaphoid':['Radius','Lunate','Trapezium','Trapezoid','Capitate'],
    'Lunate':['Radius','Scaphoid','Triquetrum','Capitate','Hamate'],
    'Triquetrum':['Ulna','Lunate','Pisiform','Hamate'],'Pisiform':['Ulna','Triquetrum'],
    'Trapezium':['Scaphoid','Trapezoid','Metacarpal I'],
    'Trapezoid':['Scaphoid','Trapezium','Capitate','Metacarpal II'],
    'Capitate':['Scaphoid','Lunate','Trapezoid','Hamate','Metacarpal II','Metacarpal III'],
    'Hamate':['Lunate','Triquetrum','Capitate','Metacarpal IV','Metacarpal V'],
    'Metacarpal I':['Trapezium','Proximal Phalanx I'],
    'Metacarpal II':['Trapezoid','Capitate','Proximal Phalanx II'],
    'Metacarpal III':['Capitate','Proximal Phalanx III'],
    'Metacarpal IV':['Hamate','Proximal Phalanx IV'],
    'Metacarpal V':['Hamate','Proximal Phalanx V'],
    'Proximal Phalanx I':['Metacarpal I','Distal Phalanx I'],'Distal Phalanx I':['Proximal Phalanx I'],
    'Proximal Phalanx II':['Metacarpal II','Middle Phalanx II'],
    'Middle Phalanx II':['Proximal Phalanx II','Distal Phalanx II'],'Distal Phalanx II':['Middle Phalanx II'],
    'Proximal Phalanx III':['Metacarpal III','Middle Phalanx III'],
    'Middle Phalanx III':['Proximal Phalanx III','Distal Phalanx III'],'Distal Phalanx III':['Middle Phalanx III'],
    'Proximal Phalanx IV':['Metacarpal IV','Middle Phalanx IV'],
    'Middle Phalanx IV':['Proximal Phalanx IV','Distal Phalanx IV'],'Distal Phalanx IV':['Middle Phalanx IV'],
    'Proximal Phalanx V':['Metacarpal V','Middle Phalanx V'],
    'Middle Phalanx V':['Proximal Phalanx V','Distal Phalanx V'],'Distal Phalanx V':['Middle Phalanx V'],
};

const HAND_B2M = {
    'Radius':'Radius','Ulna':'Ulna',
    'Scaphoid':'Scaphoid','Lunate':'Lunate','Triquetrum':'Triquetrum','Pisiform':'Pisiform',
    'Trapezium':'Trapezium','Trapezoid':'Trapezoid','Capitate':'Capitate','Hamate':'Hamate',
    'Metacarpal I':'1st_metacarpal','Metacarpal II':'2nd_metacarpal',
    'Metacarpal III':'3rd_metacarpal','Metacarpal IV':'4th_metacarpal','Metacarpal V':'5th_metacarpal',
    'Proximal Phalanx I':'phalanx_of_1st','Distal Phalanx I':'phalanx_of_1st',
    'Proximal Phalanx II':'phalanx_of_2d','Middle Phalanx II':'phalanx_of_2d','Distal Phalanx II':'phalanx_of_2d',
    'Proximal Phalanx III':'phalanx_of_3d','Middle Phalanx III':'phalanx_of_3d','Distal Phalanx III':'phalanx_of_3d',
    'Proximal Phalanx IV':'phalanx_of_4th','Middle Phalanx IV':'phalanx_of_4th','Distal Phalanx IV':'phalanx_of_4th',
    'Proximal Phalanx V':'phalanx_of_5th','Middle Phalanx V':'phalanx_of_5th','Distal Phalanx V':'phalanx_of_5th'
};

const HAND_ALL = Object.keys(HAND_GRAPH);
const HAND_TOTAL = HAND_ALL.length;
const HAND_START = 'Radius';
</script>

<script src="../js/3d/handEngine.js"></script>
<script src="../js/ui/floodFillUI.js"></script>

<script type="text/babel">
const { useState, useEffect, useMemo, useCallback } = React;

function HandGame() {
    const [guessed, setGuessed] = useState(() => new Set([HAND_START]));
    const [bad, setBad] = useState([]);
    const [left, setLeft] = useState((HAND_TOTAL - 1) + 5);
    const [max, setMax] = useState((HAND_TOTAL - 1) + 5);
    const [input, setInput] = useState('');
    const [selIdx, setSelIdx] = useState(-1);
    const [phase, setPhase] = useState('playing');
    const [reveal, setReveal] = useState(false);

    const startNew = useCallback(() => {
        const total = (HAND_TOTAL - 1) + 5;
        setGuessed(new Set([HAND_START]));
        setBad([]); setLeft(total); setMax(total);
        setInput(''); setSelIdx(-1); setPhase('playing'); setReveal(false);
        try { window.reset3D && window.reset3D(); } catch(e) {}
    }, []);

    useEffect(() => { startNew(); }, []);

    const frontier = useMemo(() => {
        const f = new Set();
        guessed.forEach(b => { (HAND_GRAPH[b]||[]).forEach(n => { if(!guessed.has(n)) f.add(n); }); });
        return f;
    }, [guessed]);

    useEffect(() => {
        const h = [];
        guessed.forEach(b => h.push({name:b, type: b===HAND_START ? 'start' : 'found'}));
        if (reveal && phase==='lost') HAND_ALL.forEach(b => { if(!guessed.has(b)) h.push({name:b,type:'reveal'}); });
        bad.forEach(b => h.push({name:b,type:'bad'}));
        try { window.update3D && window.update3D(h); } catch(e) {}
    }, [guessed, bad, reveal, phase]);

    const suggestions = useMemo(() => {
        if (!input.trim()) return [];
        return HAND_ALL.filter(b =>
            b.toLowerCase().includes(input.toLowerCase()) &&
            !guessed.has(b) && !bad.includes(b)
        ).slice(0, 7);
    }, [input, guessed, bad]);

    useEffect(() => { setSelIdx(-1); }, [suggestions.length]);

    const submit = useCallback((g) => {
        if (phase !== 'playing' || !g || !HAND_ALL.includes(g) || guessed.has(g)) return;
        const nl = left - 1; setLeft(nl);
        if (frontier.has(g)) {
            const ng = new Set(guessed); ng.add(g); setGuessed(ng);
            if (ng.size === HAND_TOTAL) { setPhase('won'); setInput(''); return; }
            if (nl <= 0) { setPhase('lost'); setInput(''); return; }
        } else {
            setBad(p => [...new Set([g, ...p])]);
            if (nl <= 0) { setPhase('lost'); setInput(''); return; }
        }
        setInput(''); setSelIdx(-1);
    }, [phase, guessed, frontier, left, bad]);

    const handleKey = (e) => {
        if (e.key === 'ArrowDown') { e.preventDefault(); setSelIdx(i => Math.min(i+1, suggestions.length-1)); }
        else if (e.key === 'ArrowUp') { e.preventDefault(); setSelIdx(i => Math.max(i-1, 0)); }
        else if (e.key === 'Enter') {
            if (selIdx >= 0 && suggestions[selIdx]) submit(suggestions[selIdx]);
            else if (suggestions.length === 1) submit(suggestions[0]);
        }
        else if (e.key === 'Escape') { setInput(''); setSelIdx(-1); }
    };

    return (
        <window.FloodFillUI
            gameTitle="âœ‹ Hand"
            accentColor="#10b981"
            state={{ start: HAND_START, total: HAND_TOTAL, guessed, bad, left, max, input, selIdx, phase, reveal, suggestions }}
            handlers={{
                onInputChange: e => setInput(e.target.value),
                onKeyDown: handleKey,
                onSubmit: submit,
                onNewGame: startNew,
                onReveal: () => setReveal(true)
            }}
        />
    );
}

ReactDOM.createRoot(document.getElementById('root')).render(<HandGame />);
</script>
</body>
</html>
