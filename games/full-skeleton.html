<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ANATOMLE | Full Skeleton</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Fraunces:ital,wght@0,700;0,900;1,700&family=DM+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="../js/data/skeletonGraph.js"></script>
    <script src="../js/data/boneMappings.js"></script>
    <script src="../js/core/pathfinding.js"></script>
    <script src="../js/core/gameLogic.js"></script>
    <style>
        * { box-sizing: border-box; }
        body { font-family: 'DM Sans', sans-serif; background: #fdf6ec; color: #2d1f14; margin: 0; overflow: hidden; }
        #cv { position: fixed; top: 104px; left: 0; right: 580px; bottom: 68px; z-index: 10;
              background: radial-gradient(ellipse at 50% 40%, #f5e8d0 0%, #ede0c8 60%, #e4d4b8 100%); }
        #ad-slot { position: fixed; top: 58px; right: 0; width: 160px; bottom: 0; z-index: 150;
              background: #fff8f0; border-left: 2px solid #e8d5c0;
              display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px; }
        #ad-slot span { font-family: 'DM Sans', sans-serif; font-size: 9px; color: #c8b8a8;
              text-transform: uppercase; letter-spacing: 0.2em; writing-mode: vertical-rl; }
        #ad-slot .ad-placeholder { width: 120px; height: 240px; border: 2px dashed #e8d5c0; border-radius: 8px; }
        .scr::-webkit-scrollbar { width: 3px; }
        .scr::-webkit-scrollbar-thumb { background: #e8d5c0; border-radius: 2px; }
        .shake { animation: shake .3s ease-in-out; }
        @keyframes shake { 0%,100%{transform:translateX(0)} 25%{transform:translateX(-4px)} 75%{transform:translateX(4px)} }
    </style>
</head>
<body>
<div id="cv"></div>
<div id="ad-slot"><div class="ad-placeholder"></div><span>Coming Soon</span></div>
<div id="root"></div>

<script src="../js/3d/skeletonEngine.js"></script>
<script src="../js/ui/pathfindingUI.js"></script>
<script src="../js/ui/howToPlay.js"></script>
<script src="../js/ui/boneInfo.js"></script>
<script src="../js/ui/boneTooltip.js"></script>

<script type="text/babel">
const { useState, useEffect, useMemo, useCallback } = React;

function SkeletonGame() {
    const [showHtp, dismissHtp] = window.useFirstVisit('full-skeleton');
    const [target, setTarget] = useState({ start: '', end: '', path: [] });
    const [chain, setChain] = useState([]);
    const [left, setLeft] = useState(10);
    const [max, setMax] = useState(10);
    const [bad, setBad] = useState([]);
    const [detours, setDetours] = useState([]);
    const [input, setInput] = useState('');
    const [selIdx, setSelIdx] = useState(-1);
    const [phase, setPhase] = useState('playing');
    const [reveal, setReveal] = useState(false);
    const [shared, setShared] = useState(false);

    const startNew = useCallback(() => {
        const g = initializeGame(SKELETON_GRAPH, { minLength: 4, maxLength: 8 });
        setTarget(g);
        setChain(g.path.map((bone, i) => ({ bone, type: i === 0 ? 'start' : 'path', guessed: i === 0 })));
        const total = calculateGuessCount(g.path.length, 2);
        setLeft(total); setMax(total);
        setBad([]); setDetours([]);
        setInput(''); setSelIdx(-1); setPhase('playing'); setReveal(false); setShared(false);
        try { window.reset3D && window.reset3D(); } catch (e) { }
    }, []);

    useEffect(() => { startNew(); }, []);

    // Re-apply highlights whenever state changes OR when model finishes loading
    const highlightRef = React.useRef([]);
    useEffect(() => {
        const h = [];
        if (reveal && phase === 'lost') {
            chain.forEach((item, idx) => {
                const isLast = idx === chain.length - 1;
                if (item.guessed && !isLast) h.push({ name: item.bone, type: item.type });
                else if (!item.guessed && !isLast) h.push({ name: item.bone, type: 'reveal' });
                else if (isLast) h.push({ name: item.bone, type: 'end' });
            });
        } else {
            chain.forEach((item, idx) => {
                const isLast = idx === chain.length - 1;
                if (item.guessed && !isLast) h.push({ name: item.bone, type: item.type });
                else if (isLast) h.push({ name: item.bone, type: 'end' });
            });
            detours.forEach(g => h.push({ name: g, type: 'detour' }));
            bad.forEach(g => h.push({ name: g, type: 'bad' }));
        }
        highlightRef.current = h;
        try { window.update3D && window.update3D(h); } catch (e) { }
    }, [chain, bad, detours, reveal, phase]);

    useEffect(() => {
        const onReady = () => { try { window.update3D && window.update3D(highlightRef.current); } catch(e){} };
        window.addEventListener('modelReady', onReady);
        return () => window.removeEventListener('modelReady', onReady);
    }, []);

    const suggestions = useMemo(() => {
        if (!input.trim()) return [];
        const guessedBones = chain.filter(c => c.guessed).map(c => c.bone);
        return Object.keys(SKELETON_GRAPH).filter(b =>
            b.toLowerCase().includes(input.toLowerCase()) &&
            !guessedBones.includes(b) &&
            b !== target.end &&
            !bad.includes(b) &&
            !detours.includes(b)
        ).slice(0, 7);
    }, [input, chain, target.end, bad, detours]);

    useEffect(() => { setSelIdx(-1); }, [suggestions.length]);

    const submit = useCallback((guess) => {
        if (phase !== 'playing' || !guess) return;
        setInput(''); setSelIdx(-1);

        // On optimal path
        if (target.path.includes(guess)) {
            const updatedChain = chain.map(item => item.bone === guess ? { ...item, guessed: true } : item);
            setChain(updatedChain);
            const guessedOptimal = updatedChain.filter(c => c.guessed).map(c => c.bone);
            if (canReachTargetWithGuessed(target.start, target.end, guessedOptimal, detours, SKELETON_GRAPH)) {
                setPhase('won'); return;
            }
            return;
        }

        // Not on optimal â€” classify via validateGuess
        const result = validateGuess(guess, target.path, target.start, target.end, SKELETON_GRAPH);
        const nl = left - 1; setLeft(nl);

        if (result.type === 'detour') {
            const updatedDetours = [...new Set([...detours, guess])];
            setDetours(updatedDetours);
            // Check win after every detour â€” path through all guessed bones counts
            const guessedOptimal = chain.filter(c => c.guessed).map(c => c.bone);
            if (canReachTargetWithGuessed(target.start, target.end, guessedOptimal, updatedDetours, SKELETON_GRAPH)) {
                setPhase('won'); return;
            }
        } else {
            setBad(prev => [...new Set([...prev, guess])]);
        }

        if (nl <= 0) setPhase('lost');
    }, [phase, chain, detours, target, left, bad]);

    const handleKey = (e) => {
        if (e.key === 'ArrowDown') { e.preventDefault(); setSelIdx(i => Math.min(i + 1, suggestions.length - 1)); }
        else if (e.key === 'ArrowUp') { e.preventDefault(); setSelIdx(i => Math.max(i - 1, 0)); }
        else if (e.key === 'Enter') {
            if (selIdx >= 0 && suggestions[selIdx]) submit(suggestions[selIdx]);
            else if (suggestions.length === 1) submit(suggestions[0]);
        }
        else if (e.key === 'Escape') { setInput(''); setSelIdx(-1); }
    };

    return (
        <>
        <window.HowToModal show={showHtp} onClose={dismissHtp} />
        <window.PathfindingUI
            gameTitle="Osteomle Â· Full Skeleton"
            mode="standard"
            state={{ target, chain, left, max, bad, detours, input, selIdx, phase, reveal, suggestions, hintUsed: false, shared }}
            handlers={{
                onInputChange: e => setInput(e.target.value),
                onKeyDown: handleKey,
                onSubmit: submit,
                onNewGame: startNew,
                onGiveUp: () => setPhase('lost'),
                onReveal: () => setReveal(true),
                onShare: () => {
                    const d = new Date();
                    const dateStr = d.toLocaleDateString('en-GB',{day:'numeric',month:'short',year:'numeric'});
                    const grid = chain.map(c => c.guessed ? (c.type==='start'?'ðŸŸ¢':'ðŸŸ¦') : 'â¬œ').join('');
                    const text = `Anatomle â€“ Full Skeleton\n${dateStr}\n${phase==='won'?'âœ…':'âŒ'}\n${grid}`;
                    navigator.clipboard.writeText(text).then(() => setShared(true));
                }
            }}
        />
        {/* In-game â“˜ icon now rendered inside pathfindingUI navbar */}
        </>
    );
}

ReactDOM.createRoot(document.getElementById('root')).render(
    <>
        <SkeletonGame />
        {typeof window.BoneTooltipLayer !== 'undefined' && <window.BoneTooltipLayer />}
    </>
);
</script>
</body>
</html>
