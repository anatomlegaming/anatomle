<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ANATOMLE | Full Skeleton</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="../js/data/skeletonGraph.js"></script>
    <script src="../js/data/boneMappings.js"></script>
    <script src="../js/core/pathfinding.js"></script>
    <script src="../js/core/gameLogic.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Fraunces:ital,wght@0,700;0,900;1,700&family=DM+Sans:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        * { box-sizing: border-box; }

        body {
            font-family: 'DM Sans', sans-serif;
            background: #fdf6ec;
            color: #2d1f14;
            margin: 0;
            overflow: hidden;
        }

        /* 3D viewport stays dark so bones are readable */
        #cv {
            position: fixed;
            top: 104px;   /* NAV_H 58 + BAR_H 46 */
            left: 0;
            right: 300px; /* PANEL_W */
            bottom: 68px; /* SRCH_H */
            z-index: 10;
            background: linear-gradient(160deg, #1a120a 0%, #0d0905 100%);
        }

        .scr::-webkit-scrollbar { width: 3px; }
        .scr::-webkit-scrollbar-thumb { background: #e8d5c0; border-radius: 2px; }

        .shake { animation: shake 0.3s ease-in-out; }
        @keyframes shake {
            0%,100% { transform: translateX(0); }
            25%      { transform: translateX(-4px); }
            75%      { transform: translateX(4px); }
        }
    </style>
</head>
<body>
<div id="cv"></div>
<div id="root"></div>

<script src="../js/3d/skeletonEngine.js"></script>
<script src="../js/ui/pathfindingUI.js"></script>

<script type="text/babel">
const { useState, useEffect, useMemo, useCallback } = React;

function SkeletonGame() {
    const [target,  setTarget]  = useState({ start: '', end: '', path: [] });
    const [chain,   setChain]   = useState([]);
    const [left,    setLeft]    = useState(10);
    const [max,     setMax]     = useState(10);
    const [bad,     setBad]     = useState([]);
    const [detours, setDetours] = useState([]);
    const [input,   setInput]   = useState('');
    const [selIdx,  setSelIdx]  = useState(-1);
    const [phase,   setPhase]   = useState('playing');
    const [reveal,  setReveal]  = useState(false);

    const startNew = useCallback(() => {
        const g = initializeGame(SKELETON_GRAPH, { minLength: 4, maxLength: 8 });
        setTarget(g);
        setChain(g.path.map((bone, i) => ({ bone, type: i === 0 ? 'start' : 'path', guessed: i === 0 })));
        const total = calculateGuessCount(g.path.length);
        setLeft(total); setMax(total);
        setBad([]); setDetours([]);
        setInput(''); setSelIdx(-1); setPhase('playing'); setReveal(false);
        try { window.reset3D && window.reset3D(); } catch (e) {}
    }, []);

    useEffect(() => { startNew(); }, []);

    useEffect(() => {
        const h = [];
        if (reveal && phase === 'lost') {
            chain.forEach((item, idx) => {
                const isLast = idx === chain.length - 1;
                if (item.guessed && !isLast) h.push({ name: item.bone, type: item.type });
                else if (!item.guessed && !isLast) h.push({ name: item.bone, type: 'reveal' });
                else if (isLast) h.push({ name: item.bone, type: 'end' });
            });
        } else {
            chain.forEach((item, idx) => {
                const isLast = idx === chain.length - 1;
                if (item.guessed && !isLast) h.push({ name: item.bone, type: item.type });
                else if (isLast) h.push({ name: item.bone, type: 'end' });
            });
            detours.forEach(g => h.push({ name: g, type: 'detour' }));
            bad.forEach(g => h.push({ name: g, type: 'bad' }));
        }
        try { window.update3D && window.update3D(h); } catch (e) {}
    }, [chain, bad, detours, reveal, phase]);

    const suggestions = useMemo(() => {
        if (!input.trim()) return [];
        const guessedBones = chain.filter(c => c.guessed).map(c => c.bone);
        return Object.keys(SKELETON_GRAPH).filter(b =>
            b.toLowerCase().includes(input.toLowerCase()) &&
            !guessedBones.includes(b) &&
            b !== target.end &&
            !bad.includes(b) &&
            !detours.includes(b)
        ).slice(0, 7);
    }, [input, chain, target.end, bad, detours]);

    useEffect(() => { setSelIdx(-1); }, [suggestions.length]);

    const submit = useCallback((guess) => {
        if (phase !== 'playing' || !guess) return;
        const isOnPath = target.path.includes(guess);
        let updatedChain = chain, updatedDetours = detours, valid = false;
        if (isOnPath) {
            updatedChain = chain.map(item => item.bone === guess ? { ...item, guessed: true } : item);
            valid = true;
        } else if (isOnValidPath(guess, target.start, target.end, SKELETON_GRAPH)) {
            updatedDetours = [...new Set([guess, ...detours])];
            valid = true;
        } else {
            setBad(prev => [...new Set([guess, ...prev])]);
        }
        const nl = left - 1; setLeft(nl);
        if (valid) {
            if (isOnPath) setChain(updatedChain); else setDetours(updatedDetours);
            const guessedOptimal = updatedChain.filter(c => c.guessed).map(c => c.bone);
            if (canReachTargetWithGuessed(target.start, target.end, guessedOptimal, updatedDetours, SKELETON_GRAPH)) {
                setPhase('won'); setInput(''); return;
            }
        }
        if (nl <= 0) setPhase('lost');
        setInput(''); setSelIdx(-1);
    }, [phase, chain, detours, target, left, bad]);

    const handleKey = (e) => {
        if (e.key === 'ArrowDown')  { e.preventDefault(); setSelIdx(i => Math.min(i + 1, suggestions.length - 1)); }
        else if (e.key === 'ArrowUp')   { e.preventDefault(); setSelIdx(i => Math.max(i - 1, 0)); }
        else if (e.key === 'Enter') {
            if (selIdx >= 0 && suggestions[selIdx]) submit(suggestions[selIdx]);
            else if (suggestions.length === 1) submit(suggestions[0]);
        }
        else if (e.key === 'Escape') { setInput(''); setSelIdx(-1); }
    };

    return (
        <window.PathfindingUI
            gameTitle="ðŸ¦´ Full Skeleton"
            state={{ target, chain, left, max, bad, detours, input, selIdx, phase, reveal, suggestions }}
            handlers={{
                onInputChange: e => setInput(e.target.value),
                onKeyDown: handleKey,
                onSubmit: submit,
                onNewGame: startNew,
                onReveal: () => setReveal(true)
            }}
        />
    );
}

ReactDOM.createRoot(document.getElementById('root')).render(<SkeletonGame />);
</script>
</body>
</html>
